/* Generated by the protocol buffer compiler.  DO NOT EDIT! */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C_NO_DEPRECATED
#define PROTOBUF_C_NO_DEPRECATED
#endif

#include "tethering.pb-c.h"
void   injector__hand_shake_req__init
                     (Injector__HandShakeReq         *message)
{
  static Injector__HandShakeReq init_value = INJECTOR__HAND_SHAKE_REQ__INIT;
  *message = init_value;
}
size_t injector__hand_shake_req__get_packed_size
                     (const Injector__HandShakeReq *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__hand_shake_req__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__hand_shake_req__pack
                     (const Injector__HandShakeReq *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__hand_shake_req__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__hand_shake_req__pack_to_buffer
                     (const Injector__HandShakeReq *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__hand_shake_req__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__HandShakeReq *
       injector__hand_shake_req__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__HandShakeReq *)
     protobuf_c_message_unpack (&injector__hand_shake_req__descriptor,
                                allocator, len, data);
}
void   injector__hand_shake_req__free_unpacked
                     (Injector__HandShakeReq *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__hand_shake_req__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__hand_shake_ans__init
                     (Injector__HandShakeAns         *message)
{
  static Injector__HandShakeAns init_value = INJECTOR__HAND_SHAKE_ANS__INIT;
  *message = init_value;
}
size_t injector__hand_shake_ans__get_packed_size
                     (const Injector__HandShakeAns *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__hand_shake_ans__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__hand_shake_ans__pack
                     (const Injector__HandShakeAns *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__hand_shake_ans__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__hand_shake_ans__pack_to_buffer
                     (const Injector__HandShakeAns *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__hand_shake_ans__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__HandShakeAns *
       injector__hand_shake_ans__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__HandShakeAns *)
     protobuf_c_message_unpack (&injector__hand_shake_ans__descriptor,
                                allocator, len, data);
}
void   injector__hand_shake_ans__free_unpacked
                     (Injector__HandShakeAns *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__hand_shake_ans__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__emulator_state__init
                     (Injector__EmulatorState         *message)
{
  static Injector__EmulatorState init_value = INJECTOR__EMULATOR_STATE__INIT;
  *message = init_value;
}
size_t injector__emulator_state__get_packed_size
                     (const Injector__EmulatorState *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__emulator_state__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__emulator_state__pack
                     (const Injector__EmulatorState *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__emulator_state__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__emulator_state__pack_to_buffer
                     (const Injector__EmulatorState *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__emulator_state__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__EmulatorState *
       injector__emulator_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__EmulatorState *)
     protobuf_c_message_unpack (&injector__emulator_state__descriptor,
                                allocator, len, data);
}
void   injector__emulator_state__free_unpacked
                     (Injector__EmulatorState *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__emulator_state__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__app_state__init
                     (Injector__AppState         *message)
{
  static Injector__AppState init_value = INJECTOR__APP_STATE__INIT;
  *message = init_value;
}
size_t injector__app_state__get_packed_size
                     (const Injector__AppState *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__app_state__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__app_state__pack
                     (const Injector__AppState *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__app_state__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__app_state__pack_to_buffer
                     (const Injector__AppState *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__app_state__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__AppState *
       injector__app_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__AppState *)
     protobuf_c_message_unpack (&injector__app_state__descriptor,
                                allocator, len, data);
}
void   injector__app_state__free_unpacked
                     (Injector__AppState *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__app_state__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__start_req__init
                     (Injector__StartReq         *message)
{
  static Injector__StartReq init_value = INJECTOR__START_REQ__INIT;
  *message = init_value;
}
size_t injector__start_req__get_packed_size
                     (const Injector__StartReq *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__start_req__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__start_req__pack
                     (const Injector__StartReq *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__start_req__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__start_req__pack_to_buffer
                     (const Injector__StartReq *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__start_req__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__StartReq *
       injector__start_req__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__StartReq *)
     protobuf_c_message_unpack (&injector__start_req__descriptor,
                                allocator, len, data);
}
void   injector__start_req__free_unpacked
                     (Injector__StartReq *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__start_req__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__start_ans__init
                     (Injector__StartAns         *message)
{
  static Injector__StartAns init_value = INJECTOR__START_ANS__INIT;
  *message = init_value;
}
size_t injector__start_ans__get_packed_size
                     (const Injector__StartAns *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__start_ans__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__start_ans__pack
                     (const Injector__StartAns *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__start_ans__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__start_ans__pack_to_buffer
                     (const Injector__StartAns *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__start_ans__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__StartAns *
       injector__start_ans__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__StartAns *)
     protobuf_c_message_unpack (&injector__start_ans__descriptor,
                                allocator, len, data);
}
void   injector__start_ans__free_unpacked
                     (Injector__StartAns *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__start_ans__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__set_event_status__init
                     (Injector__SetEventStatus         *message)
{
  static Injector__SetEventStatus init_value = INJECTOR__SET_EVENT_STATUS__INIT;
  *message = init_value;
}
size_t injector__set_event_status__get_packed_size
                     (const Injector__SetEventStatus *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__set_event_status__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__set_event_status__pack
                     (const Injector__SetEventStatus *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__set_event_status__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__set_event_status__pack_to_buffer
                     (const Injector__SetEventStatus *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__set_event_status__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__SetEventStatus *
       injector__set_event_status__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__SetEventStatus *)
     protobuf_c_message_unpack (&injector__set_event_status__descriptor,
                                allocator, len, data);
}
void   injector__set_event_status__free_unpacked
                     (Injector__SetEventStatus *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__set_event_status__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__event_msg__init
                     (Injector__EventMsg         *message)
{
  static Injector__EventMsg init_value = INJECTOR__EVENT_MSG__INIT;
  *message = init_value;
}
size_t injector__event_msg__get_packed_size
                     (const Injector__EventMsg *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__event_msg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__event_msg__pack
                     (const Injector__EventMsg *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__event_msg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__event_msg__pack_to_buffer
                     (const Injector__EventMsg *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__event_msg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__EventMsg *
       injector__event_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__EventMsg *)
     protobuf_c_message_unpack (&injector__event_msg__descriptor,
                                allocator, len, data);
}
void   injector__event_msg__free_unpacked
                     (Injector__EventMsg *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__event_msg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__event_terminate__init
                     (Injector__EventTerminate         *message)
{
  static Injector__EventTerminate init_value = INJECTOR__EVENT_TERMINATE__INIT;
  *message = init_value;
}
size_t injector__event_terminate__get_packed_size
                     (const Injector__EventTerminate *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__event_terminate__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__event_terminate__pack
                     (const Injector__EventTerminate *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__event_terminate__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__event_terminate__pack_to_buffer
                     (const Injector__EventTerminate *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__event_terminate__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__EventTerminate *
       injector__event_terminate__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__EventTerminate *)
     protobuf_c_message_unpack (&injector__event_terminate__descriptor,
                                allocator, len, data);
}
void   injector__event_terminate__free_unpacked
                     (Injector__EventTerminate *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__event_terminate__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__set_sensor_status__init
                     (Injector__SetSensorStatus         *message)
{
  static Injector__SetSensorStatus init_value = INJECTOR__SET_SENSOR_STATUS__INIT;
  *message = init_value;
}
size_t injector__set_sensor_status__get_packed_size
                     (const Injector__SetSensorStatus *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__set_sensor_status__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__set_sensor_status__pack
                     (const Injector__SetSensorStatus *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__set_sensor_status__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__set_sensor_status__pack_to_buffer
                     (const Injector__SetSensorStatus *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__set_sensor_status__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__SetSensorStatus *
       injector__set_sensor_status__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__SetSensorStatus *)
     protobuf_c_message_unpack (&injector__set_sensor_status__descriptor,
                                allocator, len, data);
}
void   injector__set_sensor_status__free_unpacked
                     (Injector__SetSensorStatus *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__set_sensor_status__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__sensor_data__init
                     (Injector__SensorData         *message)
{
  static Injector__SensorData init_value = INJECTOR__SENSOR_DATA__INIT;
  *message = init_value;
}
size_t injector__sensor_data__get_packed_size
                     (const Injector__SensorData *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__sensor_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__sensor_data__pack
                     (const Injector__SensorData *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__sensor_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__sensor_data__pack_to_buffer
                     (const Injector__SensorData *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__sensor_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__SensorData *
       injector__sensor_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__SensorData *)
     protobuf_c_message_unpack (&injector__sensor_data__descriptor,
                                allocator, len, data);
}
void   injector__sensor_data__free_unpacked
                     (Injector__SensorData *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__sensor_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__sensor_msg__init
                     (Injector__SensorMsg         *message)
{
  static Injector__SensorMsg init_value = INJECTOR__SENSOR_MSG__INIT;
  *message = init_value;
}
size_t injector__sensor_msg__get_packed_size
                     (const Injector__SensorMsg *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__sensor_msg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__sensor_msg__pack
                     (const Injector__SensorMsg *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__sensor_msg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__sensor_msg__pack_to_buffer
                     (const Injector__SensorMsg *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__sensor_msg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__SensorMsg *
       injector__sensor_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__SensorMsg *)
     protobuf_c_message_unpack (&injector__sensor_msg__descriptor,
                                allocator, len, data);
}
void   injector__sensor_msg__free_unpacked
                     (Injector__SensorMsg *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__sensor_msg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__resolution__init
                     (Injector__Resolution         *message)
{
  static Injector__Resolution init_value = INJECTOR__RESOLUTION__INIT;
  *message = init_value;
}
size_t injector__resolution__get_packed_size
                     (const Injector__Resolution *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__resolution__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__resolution__pack
                     (const Injector__Resolution *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__resolution__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__resolution__pack_to_buffer
                     (const Injector__Resolution *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__resolution__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__Resolution *
       injector__resolution__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__Resolution *)
     protobuf_c_message_unpack (&injector__resolution__descriptor,
                                allocator, len, data);
}
void   injector__resolution__free_unpacked
                     (Injector__Resolution *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__resolution__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__multi_touch_max_count__init
                     (Injector__MultiTouchMaxCount         *message)
{
  static Injector__MultiTouchMaxCount init_value = INJECTOR__MULTI_TOUCH_MAX_COUNT__INIT;
  *message = init_value;
}
size_t injector__multi_touch_max_count__get_packed_size
                     (const Injector__MultiTouchMaxCount *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_max_count__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__multi_touch_max_count__pack
                     (const Injector__MultiTouchMaxCount *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_max_count__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__multi_touch_max_count__pack_to_buffer
                     (const Injector__MultiTouchMaxCount *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_max_count__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__MultiTouchMaxCount *
       injector__multi_touch_max_count__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__MultiTouchMaxCount *)
     protobuf_c_message_unpack (&injector__multi_touch_max_count__descriptor,
                                allocator, len, data);
}
void   injector__multi_touch_max_count__free_unpacked
                     (Injector__MultiTouchMaxCount *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_max_count__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__multi_touch_data__init
                     (Injector__MultiTouchData         *message)
{
  static Injector__MultiTouchData init_value = INJECTOR__MULTI_TOUCH_DATA__INIT;
  *message = init_value;
}
size_t injector__multi_touch_data__get_packed_size
                     (const Injector__MultiTouchData *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__multi_touch_data__pack
                     (const Injector__MultiTouchData *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__multi_touch_data__pack_to_buffer
                     (const Injector__MultiTouchData *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__MultiTouchData *
       injector__multi_touch_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__MultiTouchData *)
     protobuf_c_message_unpack (&injector__multi_touch_data__descriptor,
                                allocator, len, data);
}
void   injector__multi_touch_data__free_unpacked
                     (Injector__MultiTouchData *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__multi_touch_msg__init
                     (Injector__MultiTouchMsg         *message)
{
  static Injector__MultiTouchMsg init_value = INJECTOR__MULTI_TOUCH_MSG__INIT;
  *message = init_value;
}
size_t injector__multi_touch_msg__get_packed_size
                     (const Injector__MultiTouchMsg *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_msg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__multi_touch_msg__pack
                     (const Injector__MultiTouchMsg *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_msg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__multi_touch_msg__pack_to_buffer
                     (const Injector__MultiTouchMsg *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_msg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__MultiTouchMsg *
       injector__multi_touch_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__MultiTouchMsg *)
     protobuf_c_message_unpack (&injector__multi_touch_msg__descriptor,
                                allocator, len, data);
}
void   injector__multi_touch_msg__free_unpacked
                     (Injector__MultiTouchMsg *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__multi_touch_msg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   injector__injector_msg__init
                     (Injector__InjectorMsg         *message)
{
  static Injector__InjectorMsg init_value = INJECTOR__INJECTOR_MSG__INIT;
  *message = init_value;
}
size_t injector__injector_msg__get_packed_size
                     (const Injector__InjectorMsg *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__injector_msg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t injector__injector_msg__pack
                     (const Injector__InjectorMsg *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__injector_msg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t injector__injector_msg__pack_to_buffer
                     (const Injector__InjectorMsg *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__injector_msg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Injector__InjectorMsg *
       injector__injector_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Injector__InjectorMsg *)
     protobuf_c_message_unpack (&injector__injector_msg__descriptor,
                                allocator, len, data);
}
void   injector__injector_msg__free_unpacked
                     (Injector__InjectorMsg *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &injector__injector_msg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor injector__hand_shake_req__field_descriptors[1] =
{
  {
    "key",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__HandShakeReq, key),
    NULL,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__hand_shake_req__field_indices_by_name[] = {
  0,   /* field[0] = key */
};
static const ProtobufCIntRange injector__hand_shake_req__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor injector__hand_shake_req__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.HandShakeReq",
  "HandShakeReq",
  "Injector__HandShakeReq",
  "injector",
  sizeof(Injector__HandShakeReq),
  1,
  injector__hand_shake_req__field_descriptors,
  injector__hand_shake_req__field_indices_by_name,
  1,  injector__hand_shake_req__number_ranges,
  (ProtobufCMessageInit) injector__hand_shake_req__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor injector__hand_shake_ans__field_descriptors[1] =
{
  {
    "result",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__HandShakeAns, result),
    &injector__result__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__hand_shake_ans__field_indices_by_name[] = {
  0,   /* field[0] = result */
};
static const ProtobufCIntRange injector__hand_shake_ans__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor injector__hand_shake_ans__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.HandShakeAns",
  "HandShakeAns",
  "Injector__HandShakeAns",
  "injector",
  sizeof(Injector__HandShakeAns),
  1,
  injector__hand_shake_ans__field_descriptors,
  injector__hand_shake_ans__field_indices_by_name,
  1,  injector__hand_shake_ans__number_ranges,
  (ProtobufCMessageInit) injector__hand_shake_ans__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor injector__emulator_state__field_descriptors[1] =
{
  {
    "state",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__EmulatorState, state),
    &injector__connection_state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__emulator_state__field_indices_by_name[] = {
  0,   /* field[0] = state */
};
static const ProtobufCIntRange injector__emulator_state__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor injector__emulator_state__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.EmulatorState",
  "EmulatorState",
  "Injector__EmulatorState",
  "injector",
  sizeof(Injector__EmulatorState),
  1,
  injector__emulator_state__field_descriptors,
  injector__emulator_state__field_indices_by_name,
  1,  injector__emulator_state__number_ranges,
  (ProtobufCMessageInit) injector__emulator_state__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor injector__app_state__field_descriptors[1] =
{
  {
    "state",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__AppState, state),
    &injector__connection_state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__app_state__field_indices_by_name[] = {
  0,   /* field[0] = state */
};
static const ProtobufCIntRange injector__app_state__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor injector__app_state__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.AppState",
  "AppState",
  "Injector__AppState",
  "injector",
  sizeof(Injector__AppState),
  1,
  injector__app_state__field_descriptors,
  injector__app_state__field_indices_by_name,
  1,  injector__app_state__number_ranges,
  (ProtobufCMessageInit) injector__app_state__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define injector__start_req__field_descriptors NULL
#define injector__start_req__field_indices_by_name NULL
#define injector__start_req__number_ranges NULL
const ProtobufCMessageDescriptor injector__start_req__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.StartReq",
  "StartReq",
  "Injector__StartReq",
  "injector",
  sizeof(Injector__StartReq),
  0,
  injector__start_req__field_descriptors,
  injector__start_req__field_indices_by_name,
  0,  injector__start_req__number_ranges,
  (ProtobufCMessageInit) injector__start_req__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor injector__start_ans__field_descriptors[1] =
{
  {
    "result",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__StartAns, result),
    &injector__result__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__start_ans__field_indices_by_name[] = {
  0,   /* field[0] = result */
};
static const ProtobufCIntRange injector__start_ans__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor injector__start_ans__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.StartAns",
  "StartAns",
  "Injector__StartAns",
  "injector",
  sizeof(Injector__StartAns),
  1,
  injector__start_ans__field_descriptors,
  injector__start_ans__field_indices_by_name,
  1,  injector__start_ans__number_ranges,
  (ProtobufCMessageInit) injector__start_ans__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor injector__set_event_status__field_descriptors[2] =
{
  {
    "event",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SetEventStatus, event),
    &injector__event__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "status",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SetEventStatus, status),
    &injector__status__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__set_event_status__field_indices_by_name[] = {
  0,   /* field[0] = event */
  1,   /* field[1] = status */
};
static const ProtobufCIntRange injector__set_event_status__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor injector__set_event_status__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.SetEventStatus",
  "SetEventStatus",
  "Injector__SetEventStatus",
  "injector",
  sizeof(Injector__SetEventStatus),
  2,
  injector__set_event_status__field_descriptors,
  injector__set_event_status__field_indices_by_name,
  1,  injector__set_event_status__number_ranges,
  (ProtobufCMessageInit) injector__set_event_status__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue injector__event_msg__type__enum_values_by_number[4] =
{
  { "START_REQ", "INJECTOR__EVENT_MSG__TYPE__START_REQ", 2 },
  { "START_ANS", "INJECTOR__EVENT_MSG__TYPE__START_ANS", 3 },
  { "TERMINATE", "INJECTOR__EVENT_MSG__TYPE__TERMINATE", 4 },
  { "EVENT_STATUS", "INJECTOR__EVENT_MSG__TYPE__EVENT_STATUS", 5 },
};
static const ProtobufCIntRange injector__event_msg__type__value_ranges[] = {
{2, 0},{0, 4}
};
const ProtobufCEnumValueIndex injector__event_msg__type__enum_values_by_name[4] =
{
  { "EVENT_STATUS", 3 },
  { "START_ANS", 1 },
  { "START_REQ", 0 },
  { "TERMINATE", 2 },
};
const ProtobufCEnumDescriptor injector__event_msg__type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "injector.EventMsg.TYPE",
  "TYPE",
  "Injector__EventMsg__TYPE",
  "injector",
  4,
  injector__event_msg__type__enum_values_by_number,
  4,
  injector__event_msg__type__enum_values_by_name,
  1,
  injector__event_msg__type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCFieldDescriptor injector__event_msg__field_descriptors[5] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__EventMsg, type),
    &injector__event_msg__type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startReq",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__EventMsg, startreq),
    &injector__start_req__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startAns",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__EventMsg, startans),
    &injector__start_ans__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "terminate",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__EventMsg, terminate),
    &injector__event_terminate__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "setStatus",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__EventMsg, setstatus),
    &injector__set_event_status__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__event_msg__field_indices_by_name[] = {
  4,   /* field[4] = setStatus */
  2,   /* field[2] = startAns */
  1,   /* field[1] = startReq */
  3,   /* field[3] = terminate */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange injector__event_msg__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor injector__event_msg__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.EventMsg",
  "EventMsg",
  "Injector__EventMsg",
  "injector",
  sizeof(Injector__EventMsg),
  5,
  injector__event_msg__field_descriptors,
  injector__event_msg__field_indices_by_name,
  1,  injector__event_msg__number_ranges,
  (ProtobufCMessageInit) injector__event_msg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define injector__event_terminate__field_descriptors NULL
#define injector__event_terminate__field_indices_by_name NULL
#define injector__event_terminate__number_ranges NULL
const ProtobufCMessageDescriptor injector__event_terminate__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.EventTerminate",
  "EventTerminate",
  "Injector__EventTerminate",
  "injector",
  sizeof(Injector__EventTerminate),
  0,
  injector__event_terminate__field_descriptors,
  injector__event_terminate__field_indices_by_name,
  0,  injector__event_terminate__number_ranges,
  (ProtobufCMessageInit) injector__event_terminate__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor injector__set_sensor_status__field_descriptors[2] =
{
  {
    "sensor",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SetSensorStatus, sensor),
    &injector__sensor_type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "status",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SetSensorStatus, status),
    &injector__status__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__set_sensor_status__field_indices_by_name[] = {
  0,   /* field[0] = sensor */
  1,   /* field[1] = status */
};
static const ProtobufCIntRange injector__set_sensor_status__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor injector__set_sensor_status__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.SetSensorStatus",
  "SetSensorStatus",
  "Injector__SetSensorStatus",
  "injector",
  sizeof(Injector__SetSensorStatus),
  2,
  injector__set_sensor_status__field_descriptors,
  injector__set_sensor_status__field_indices_by_name,
  1,  injector__set_sensor_status__number_ranges,
  (ProtobufCMessageInit) injector__set_sensor_status__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char injector__sensor_data__x__default_value[] = "0";
char injector__sensor_data__y__default_value[] = "0";
char injector__sensor_data__z__default_value[] = "0";
static const ProtobufCFieldDescriptor injector__sensor_data__field_descriptors[4] =
{
  {
    "sensor",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SensorData, sensor),
    &injector__sensor_type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "x",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SensorData, x),
    NULL,
    &injector__sensor_data__x__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "y",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SensorData, y),
    NULL,
    &injector__sensor_data__y__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "z",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SensorData, z),
    NULL,
    &injector__sensor_data__z__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__sensor_data__field_indices_by_name[] = {
  0,   /* field[0] = sensor */
  1,   /* field[1] = x */
  2,   /* field[2] = y */
  3,   /* field[3] = z */
};
static const ProtobufCIntRange injector__sensor_data__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor injector__sensor_data__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.SensorData",
  "SensorData",
  "Injector__SensorData",
  "injector",
  sizeof(Injector__SensorData),
  4,
  injector__sensor_data__field_descriptors,
  injector__sensor_data__field_indices_by_name,
  1,  injector__sensor_data__number_ranges,
  (ProtobufCMessageInit) injector__sensor_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue injector__sensor_msg__type__enum_values_by_number[5] =
{
  { "START_REQ", "INJECTOR__SENSOR_MSG__TYPE__START_REQ", 2 },
  { "START_ANS", "INJECTOR__SENSOR_MSG__TYPE__START_ANS", 3 },
  { "TERMINATE", "INJECTOR__SENSOR_MSG__TYPE__TERMINATE", 4 },
  { "SENSOR_STATUS", "INJECTOR__SENSOR_MSG__TYPE__SENSOR_STATUS", 5 },
  { "SENSOR_DATA", "INJECTOR__SENSOR_MSG__TYPE__SENSOR_DATA", 6 },
};
static const ProtobufCIntRange injector__sensor_msg__type__value_ranges[] = {
{2, 0},{0, 5}
};
const ProtobufCEnumValueIndex injector__sensor_msg__type__enum_values_by_name[5] =
{
  { "SENSOR_DATA", 4 },
  { "SENSOR_STATUS", 3 },
  { "START_ANS", 1 },
  { "START_REQ", 0 },
  { "TERMINATE", 2 },
};
const ProtobufCEnumDescriptor injector__sensor_msg__type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "injector.SensorMsg.Type",
  "Type",
  "Injector__SensorMsg__Type",
  "injector",
  5,
  injector__sensor_msg__type__enum_values_by_number,
  5,
  injector__sensor_msg__type__enum_values_by_name,
  1,
  injector__sensor_msg__type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCFieldDescriptor injector__sensor_msg__field_descriptors[6] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SensorMsg, type),
    &injector__sensor_msg__type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startReq",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SensorMsg, startreq),
    &injector__start_req__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startAns",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SensorMsg, startans),
    &injector__start_ans__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "terminate",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SensorMsg, terminate),
    &injector__event_terminate__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "setStatus",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SensorMsg, setstatus),
    &injector__set_sensor_status__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__SensorMsg, data),
    &injector__sensor_data__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__sensor_msg__field_indices_by_name[] = {
  5,   /* field[5] = data */
  4,   /* field[4] = setStatus */
  2,   /* field[2] = startAns */
  1,   /* field[1] = startReq */
  3,   /* field[3] = terminate */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange injector__sensor_msg__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor injector__sensor_msg__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.SensorMsg",
  "SensorMsg",
  "Injector__SensorMsg",
  "injector",
  sizeof(Injector__SensorMsg),
  6,
  injector__sensor_msg__field_descriptors,
  injector__sensor_msg__field_indices_by_name,
  1,  injector__sensor_msg__number_ranges,
  (ProtobufCMessageInit) injector__sensor_msg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor injector__resolution__field_descriptors[2] =
{
  {
    "width",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__Resolution, width),
    NULL,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "height",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__Resolution, height),
    NULL,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__resolution__field_indices_by_name[] = {
  1,   /* field[1] = height */
  0,   /* field[0] = width */
};
static const ProtobufCIntRange injector__resolution__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor injector__resolution__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.Resolution",
  "Resolution",
  "Injector__Resolution",
  "injector",
  sizeof(Injector__Resolution),
  2,
  injector__resolution__field_descriptors,
  injector__resolution__field_indices_by_name,
  1,  injector__resolution__number_ranges,
  (ProtobufCMessageInit) injector__resolution__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const int32_t injector__multi_touch_max_count__max__default_value = 10;
static const ProtobufCFieldDescriptor injector__multi_touch_max_count__field_descriptors[1] =
{
  {
    "max",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchMaxCount, has_max),
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchMaxCount, max),
    NULL,
    &injector__multi_touch_max_count__max__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__multi_touch_max_count__field_indices_by_name[] = {
  0,   /* field[0] = max */
};
static const ProtobufCIntRange injector__multi_touch_max_count__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor injector__multi_touch_max_count__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.MultiTouchMaxCount",
  "MultiTouchMaxCount",
  "Injector__MultiTouchMaxCount",
  "injector",
  sizeof(Injector__MultiTouchMaxCount),
  1,
  injector__multi_touch_max_count__field_descriptors,
  injector__multi_touch_max_count__field_indices_by_name,
  1,  injector__multi_touch_max_count__number_ranges,
  (ProtobufCMessageInit) injector__multi_touch_max_count__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const int32_t injector__multi_touch_data__index__default_value = 0;
static const float injector__multi_touch_data__x_point__default_value = 0;
static const float injector__multi_touch_data__y_point__default_value = 0;
static const ProtobufCFieldDescriptor injector__multi_touch_data__field_descriptors[4] =
{
  {
    "index",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchData, has_index),
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchData, index),
    NULL,
    &injector__multi_touch_data__index__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "xPoint",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchData, has_xpoint),
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchData, xpoint),
    NULL,
    &injector__multi_touch_data__x_point__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "yPoint",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchData, has_ypoint),
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchData, ypoint),
    NULL,
    &injector__multi_touch_data__y_point__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "status",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchData, has_status),
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchData, status),
    &injector__touch_status__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__multi_touch_data__field_indices_by_name[] = {
  0,   /* field[0] = index */
  3,   /* field[3] = status */
  1,   /* field[1] = xPoint */
  2,   /* field[2] = yPoint */
};
static const ProtobufCIntRange injector__multi_touch_data__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor injector__multi_touch_data__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.MultiTouchData",
  "MultiTouchData",
  "Injector__MultiTouchData",
  "injector",
  sizeof(Injector__MultiTouchData),
  4,
  injector__multi_touch_data__field_descriptors,
  injector__multi_touch_data__field_indices_by_name,
  1,  injector__multi_touch_data__number_ranges,
  (ProtobufCMessageInit) injector__multi_touch_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue injector__multi_touch_msg__type__enum_values_by_number[6] =
{
  { "START_REQ", "INJECTOR__MULTI_TOUCH_MSG__TYPE__START_REQ", 2 },
  { "START_ANS", "INJECTOR__MULTI_TOUCH_MSG__TYPE__START_ANS", 3 },
  { "TERMINATE", "INJECTOR__MULTI_TOUCH_MSG__TYPE__TERMINATE", 4 },
  { "MAX_COUNT", "INJECTOR__MULTI_TOUCH_MSG__TYPE__MAX_COUNT", 5 },
  { "TOUCH_DATA", "INJECTOR__MULTI_TOUCH_MSG__TYPE__TOUCH_DATA", 6 },
  { "RESOLUTION", "INJECTOR__MULTI_TOUCH_MSG__TYPE__RESOLUTION", 7 },
};
static const ProtobufCIntRange injector__multi_touch_msg__type__value_ranges[] = {
{2, 0},{0, 6}
};
const ProtobufCEnumValueIndex injector__multi_touch_msg__type__enum_values_by_name[6] =
{
  { "MAX_COUNT", 3 },
  { "RESOLUTION", 5 },
  { "START_ANS", 1 },
  { "START_REQ", 0 },
  { "TERMINATE", 2 },
  { "TOUCH_DATA", 4 },
};
const ProtobufCEnumDescriptor injector__multi_touch_msg__type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "injector.MultiTouchMsg.Type",
  "Type",
  "Injector__MultiTouchMsg__Type",
  "injector",
  6,
  injector__multi_touch_msg__type__enum_values_by_number,
  6,
  injector__multi_touch_msg__type__enum_values_by_name,
  1,
  injector__multi_touch_msg__type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCFieldDescriptor injector__multi_touch_msg__field_descriptors[7] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchMsg, type),
    &injector__multi_touch_msg__type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startReq",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchMsg, startreq),
    &injector__start_req__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startAns",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchMsg, startans),
    &injector__start_ans__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "terminate",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchMsg, terminate),
    &injector__event_terminate__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "maxCount",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchMsg, maxcount),
    &injector__multi_touch_max_count__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "touchData",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchMsg, touchdata),
    &injector__multi_touch_data__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "resolution",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__MultiTouchMsg, resolution),
    &injector__resolution__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__multi_touch_msg__field_indices_by_name[] = {
  4,   /* field[4] = maxCount */
  6,   /* field[6] = resolution */
  2,   /* field[2] = startAns */
  1,   /* field[1] = startReq */
  3,   /* field[3] = terminate */
  5,   /* field[5] = touchData */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange injector__multi_touch_msg__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 7 }
};
const ProtobufCMessageDescriptor injector__multi_touch_msg__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.MultiTouchMsg",
  "MultiTouchMsg",
  "Injector__MultiTouchMsg",
  "injector",
  sizeof(Injector__MultiTouchMsg),
  7,
  injector__multi_touch_msg__field_descriptors,
  injector__multi_touch_msg__field_indices_by_name,
  1,  injector__multi_touch_msg__number_ranges,
  (ProtobufCMessageInit) injector__multi_touch_msg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue injector__injector_msg__type__enum_values_by_number[7] =
{
  { "HANDSHAKE_REQ", "INJECTOR__INJECTOR_MSG__TYPE__HANDSHAKE_REQ", 2 },
  { "HANDSHAKE_ANS", "INJECTOR__INJECTOR_MSG__TYPE__HANDSHAKE_ANS", 3 },
  { "EMUL_STATE", "INJECTOR__INJECTOR_MSG__TYPE__EMUL_STATE", 4 },
  { "APP_STATE", "INJECTOR__INJECTOR_MSG__TYPE__APP_STATE", 5 },
  { "EVENT_MSG", "INJECTOR__INJECTOR_MSG__TYPE__EVENT_MSG", 6 },
  { "SENSOR_MSG", "INJECTOR__INJECTOR_MSG__TYPE__SENSOR_MSG", 7 },
  { "TOUCH_MSG", "INJECTOR__INJECTOR_MSG__TYPE__TOUCH_MSG", 8 },
};
static const ProtobufCIntRange injector__injector_msg__type__value_ranges[] = {
{2, 0},{0, 7}
};
const ProtobufCEnumValueIndex injector__injector_msg__type__enum_values_by_name[7] =
{
  { "APP_STATE", 3 },
  { "EMUL_STATE", 2 },
  { "EVENT_MSG", 4 },
  { "HANDSHAKE_ANS", 1 },
  { "HANDSHAKE_REQ", 0 },
  { "SENSOR_MSG", 5 },
  { "TOUCH_MSG", 6 },
};
const ProtobufCEnumDescriptor injector__injector_msg__type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "injector.InjectorMsg.Type",
  "Type",
  "Injector__InjectorMsg__Type",
  "injector",
  7,
  injector__injector_msg__type__enum_values_by_number,
  7,
  injector__injector_msg__type__enum_values_by_name,
  1,
  injector__injector_msg__type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCFieldDescriptor injector__injector_msg__field_descriptors[8] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__InjectorMsg, type),
    &injector__injector_msg__type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "handShakeReq",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__InjectorMsg, handshakereq),
    &injector__hand_shake_req__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "handShakeAns",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__InjectorMsg, handshakeans),
    &injector__hand_shake_ans__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "emulState",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__InjectorMsg, emulstate),
    &injector__emulator_state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "appState",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__InjectorMsg, appstate),
    &injector__app_state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eventMsg",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__InjectorMsg, eventmsg),
    &injector__event_msg__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sensorMsg",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__InjectorMsg, sensormsg),
    &injector__sensor_msg__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "touchMsg",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Injector__InjectorMsg, touchmsg),
    &injector__multi_touch_msg__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned injector__injector_msg__field_indices_by_name[] = {
  4,   /* field[4] = appState */
  3,   /* field[3] = emulState */
  5,   /* field[5] = eventMsg */
  2,   /* field[2] = handShakeAns */
  1,   /* field[1] = handShakeReq */
  6,   /* field[6] = sensorMsg */
  7,   /* field[7] = touchMsg */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange injector__injector_msg__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 8 }
};
const ProtobufCMessageDescriptor injector__injector_msg__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "injector.InjectorMsg",
  "InjectorMsg",
  "Injector__InjectorMsg",
  "injector",
  sizeof(Injector__InjectorMsg),
  8,
  injector__injector_msg__field_descriptors,
  injector__injector_msg__field_indices_by_name,
  1,  injector__injector_msg__number_ranges,
  (ProtobufCMessageInit) injector__injector_msg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue injector__result__enum_values_by_number[3] =
{
  { "SUCCESS", "INJECTOR__RESULT__SUCCESS", 1 },
  { "FAILURE", "INJECTOR__RESULT__FAILURE", 2 },
  { "CANCEL", "INJECTOR__RESULT__CANCEL", 3 },
};
static const ProtobufCIntRange injector__result__value_ranges[] = {
{1, 0},{0, 3}
};
const ProtobufCEnumValueIndex injector__result__enum_values_by_name[3] =
{
  { "CANCEL", 2 },
  { "FAILURE", 1 },
  { "SUCCESS", 0 },
};
const ProtobufCEnumDescriptor injector__result__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "injector.Result",
  "Result",
  "Injector__Result",
  "injector",
  3,
  injector__result__enum_values_by_number,
  3,
  injector__result__enum_values_by_name,
  1,
  injector__result__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue injector__connection_state__enum_values_by_number[3] =
{
  { "CONNECT", "INJECTOR__CONNECTION_STATE__CONNECT", 1 },
  { "DISCONNECT", "INJECTOR__CONNECTION_STATE__DISCONNECT", 2 },
  { "TERMINATE", "INJECTOR__CONNECTION_STATE__TERMINATE", 3 },
};
static const ProtobufCIntRange injector__connection_state__value_ranges[] = {
{1, 0},{0, 3}
};
const ProtobufCEnumValueIndex injector__connection_state__enum_values_by_name[3] =
{
  { "CONNECT", 0 },
  { "DISCONNECT", 1 },
  { "TERMINATE", 2 },
};
const ProtobufCEnumDescriptor injector__connection_state__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "injector.ConnectionState",
  "ConnectionState",
  "Injector__ConnectionState",
  "injector",
  3,
  injector__connection_state__enum_values_by_number,
  3,
  injector__connection_state__enum_values_by_name,
  1,
  injector__connection_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue injector__event__enum_values_by_number[2] =
{
  { "SENSOR", "INJECTOR__EVENT__SENSOR", 1 },
  { "MULTITOUCH", "INJECTOR__EVENT__MULTITOUCH", 2 },
};
static const ProtobufCIntRange injector__event__value_ranges[] = {
{1, 0},{0, 2}
};
const ProtobufCEnumValueIndex injector__event__enum_values_by_name[2] =
{
  { "MULTITOUCH", 1 },
  { "SENSOR", 0 },
};
const ProtobufCEnumDescriptor injector__event__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "injector.Event",
  "Event",
  "Injector__Event",
  "injector",
  2,
  injector__event__enum_values_by_number,
  2,
  injector__event__enum_values_by_name,
  1,
  injector__event__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue injector__status__enum_values_by_number[2] =
{
  { "ENABLE", "INJECTOR__STATUS__ENABLE", 1 },
  { "DISABLE", "INJECTOR__STATUS__DISABLE", 2 },
};
static const ProtobufCIntRange injector__status__value_ranges[] = {
{1, 0},{0, 2}
};
const ProtobufCEnumValueIndex injector__status__enum_values_by_name[2] =
{
  { "DISABLE", 1 },
  { "ENABLE", 0 },
};
const ProtobufCEnumDescriptor injector__status__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "injector.Status",
  "Status",
  "Injector__Status",
  "injector",
  2,
  injector__status__enum_values_by_number,
  2,
  injector__status__enum_values_by_name,
  1,
  injector__status__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue injector__sensor_type__enum_values_by_number[5] =
{
  { "ACCEL", "INJECTOR__SENSOR_TYPE__ACCEL", 1 },
  { "MAGNETIC", "INJECTOR__SENSOR_TYPE__MAGNETIC", 2 },
  { "GYROSCOPE", "INJECTOR__SENSOR_TYPE__GYROSCOPE", 3 },
  { "PROXIMITY", "INJECTOR__SENSOR_TYPE__PROXIMITY", 4 },
  { "LIGHT", "INJECTOR__SENSOR_TYPE__LIGHT", 5 },
};
static const ProtobufCIntRange injector__sensor_type__value_ranges[] = {
{1, 0},{0, 5}
};
const ProtobufCEnumValueIndex injector__sensor_type__enum_values_by_name[5] =
{
  { "ACCEL", 0 },
  { "GYROSCOPE", 2 },
  { "LIGHT", 4 },
  { "MAGNETIC", 1 },
  { "PROXIMITY", 3 },
};
const ProtobufCEnumDescriptor injector__sensor_type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "injector.SensorType",
  "SensorType",
  "Injector__SensorType",
  "injector",
  5,
  injector__sensor_type__enum_values_by_number,
  5,
  injector__sensor_type__enum_values_by_name,
  1,
  injector__sensor_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue injector__touch_status__enum_values_by_number[2] =
{
  { "PRESS", "INJECTOR__TOUCH_STATUS__PRESS", 1 },
  { "RELEASE", "INJECTOR__TOUCH_STATUS__RELEASE", 2 },
};
static const ProtobufCIntRange injector__touch_status__value_ranges[] = {
{1, 0},{0, 2}
};
const ProtobufCEnumValueIndex injector__touch_status__enum_values_by_name[2] =
{
  { "PRESS", 0 },
  { "RELEASE", 1 },
};
const ProtobufCEnumDescriptor injector__touch_status__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "injector.TouchStatus",
  "TouchStatus",
  "Injector__TouchStatus",
  "injector",
  2,
  injector__touch_status__enum_values_by_number,
  2,
  injector__touch_status__enum_values_by_name,
  1,
  injector__touch_status__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
