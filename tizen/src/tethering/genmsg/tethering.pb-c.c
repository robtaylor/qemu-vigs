/* Generated by the protocol buffer compiler.  DO NOT EDIT! */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C_NO_DEPRECATED
#define PROTOBUF_C_NO_DEPRECATED
#endif

#include "tethering.pb-c.h"
void   tethering__hand_shake_req__init
                     (Tethering__HandShakeReq         *message)
{
  static Tethering__HandShakeReq init_value = TETHERING__HAND_SHAKE_REQ__INIT;
  *message = init_value;
}
size_t tethering__hand_shake_req__get_packed_size
                     (const Tethering__HandShakeReq *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hand_shake_req__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__hand_shake_req__pack
                     (const Tethering__HandShakeReq *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hand_shake_req__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__hand_shake_req__pack_to_buffer
                     (const Tethering__HandShakeReq *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hand_shake_req__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__HandShakeReq *
       tethering__hand_shake_req__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__HandShakeReq *)
     protobuf_c_message_unpack (&tethering__hand_shake_req__descriptor,
                                allocator, len, data);
}
void   tethering__hand_shake_req__free_unpacked
                     (Tethering__HandShakeReq *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hand_shake_req__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__hand_shake_ans__init
                     (Tethering__HandShakeAns         *message)
{
  static Tethering__HandShakeAns init_value = TETHERING__HAND_SHAKE_ANS__INIT;
  *message = init_value;
}
size_t tethering__hand_shake_ans__get_packed_size
                     (const Tethering__HandShakeAns *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hand_shake_ans__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__hand_shake_ans__pack
                     (const Tethering__HandShakeAns *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hand_shake_ans__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__hand_shake_ans__pack_to_buffer
                     (const Tethering__HandShakeAns *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hand_shake_ans__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__HandShakeAns *
       tethering__hand_shake_ans__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__HandShakeAns *)
     protobuf_c_message_unpack (&tethering__hand_shake_ans__descriptor,
                                allocator, len, data);
}
void   tethering__hand_shake_ans__free_unpacked
                     (Tethering__HandShakeAns *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hand_shake_ans__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__emulator_state__init
                     (Tethering__EmulatorState         *message)
{
  static Tethering__EmulatorState init_value = TETHERING__EMULATOR_STATE__INIT;
  *message = init_value;
}
size_t tethering__emulator_state__get_packed_size
                     (const Tethering__EmulatorState *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__emulator_state__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__emulator_state__pack
                     (const Tethering__EmulatorState *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__emulator_state__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__emulator_state__pack_to_buffer
                     (const Tethering__EmulatorState *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__emulator_state__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__EmulatorState *
       tethering__emulator_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__EmulatorState *)
     protobuf_c_message_unpack (&tethering__emulator_state__descriptor,
                                allocator, len, data);
}
void   tethering__emulator_state__free_unpacked
                     (Tethering__EmulatorState *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__emulator_state__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__app_state__init
                     (Tethering__AppState         *message)
{
  static Tethering__AppState init_value = TETHERING__APP_STATE__INIT;
  *message = init_value;
}
size_t tethering__app_state__get_packed_size
                     (const Tethering__AppState *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__app_state__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__app_state__pack
                     (const Tethering__AppState *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__app_state__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__app_state__pack_to_buffer
                     (const Tethering__AppState *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__app_state__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__AppState *
       tethering__app_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__AppState *)
     protobuf_c_message_unpack (&tethering__app_state__descriptor,
                                allocator, len, data);
}
void   tethering__app_state__free_unpacked
                     (Tethering__AppState *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__app_state__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__start_req__init
                     (Tethering__StartReq         *message)
{
  static Tethering__StartReq init_value = TETHERING__START_REQ__INIT;
  *message = init_value;
}
size_t tethering__start_req__get_packed_size
                     (const Tethering__StartReq *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__start_req__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__start_req__pack
                     (const Tethering__StartReq *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__start_req__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__start_req__pack_to_buffer
                     (const Tethering__StartReq *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__start_req__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__StartReq *
       tethering__start_req__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__StartReq *)
     protobuf_c_message_unpack (&tethering__start_req__descriptor,
                                allocator, len, data);
}
void   tethering__start_req__free_unpacked
                     (Tethering__StartReq *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__start_req__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__start_ans__init
                     (Tethering__StartAns         *message)
{
  static Tethering__StartAns init_value = TETHERING__START_ANS__INIT;
  *message = init_value;
}
size_t tethering__start_ans__get_packed_size
                     (const Tethering__StartAns *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__start_ans__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__start_ans__pack
                     (const Tethering__StartAns *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__start_ans__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__start_ans__pack_to_buffer
                     (const Tethering__StartAns *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__start_ans__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__StartAns *
       tethering__start_ans__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__StartAns *)
     protobuf_c_message_unpack (&tethering__start_ans__descriptor,
                                allocator, len, data);
}
void   tethering__start_ans__free_unpacked
                     (Tethering__StartAns *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__start_ans__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__set_event_status__init
                     (Tethering__SetEventStatus         *message)
{
  static Tethering__SetEventStatus init_value = TETHERING__SET_EVENT_STATUS__INIT;
  *message = init_value;
}
size_t tethering__set_event_status__get_packed_size
                     (const Tethering__SetEventStatus *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__set_event_status__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__set_event_status__pack
                     (const Tethering__SetEventStatus *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__set_event_status__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__set_event_status__pack_to_buffer
                     (const Tethering__SetEventStatus *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__set_event_status__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__SetEventStatus *
       tethering__set_event_status__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__SetEventStatus *)
     protobuf_c_message_unpack (&tethering__set_event_status__descriptor,
                                allocator, len, data);
}
void   tethering__set_event_status__free_unpacked
                     (Tethering__SetEventStatus *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__set_event_status__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__event_msg__init
                     (Tethering__EventMsg         *message)
{
  static Tethering__EventMsg init_value = TETHERING__EVENT_MSG__INIT;
  *message = init_value;
}
size_t tethering__event_msg__get_packed_size
                     (const Tethering__EventMsg *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__event_msg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__event_msg__pack
                     (const Tethering__EventMsg *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__event_msg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__event_msg__pack_to_buffer
                     (const Tethering__EventMsg *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__event_msg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__EventMsg *
       tethering__event_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__EventMsg *)
     protobuf_c_message_unpack (&tethering__event_msg__descriptor,
                                allocator, len, data);
}
void   tethering__event_msg__free_unpacked
                     (Tethering__EventMsg *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__event_msg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__event_terminate__init
                     (Tethering__EventTerminate         *message)
{
  static Tethering__EventTerminate init_value = TETHERING__EVENT_TERMINATE__INIT;
  *message = init_value;
}
size_t tethering__event_terminate__get_packed_size
                     (const Tethering__EventTerminate *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__event_terminate__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__event_terminate__pack
                     (const Tethering__EventTerminate *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__event_terminate__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__event_terminate__pack_to_buffer
                     (const Tethering__EventTerminate *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__event_terminate__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__EventTerminate *
       tethering__event_terminate__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__EventTerminate *)
     protobuf_c_message_unpack (&tethering__event_terminate__descriptor,
                                allocator, len, data);
}
void   tethering__event_terminate__free_unpacked
                     (Tethering__EventTerminate *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__event_terminate__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__set_sensor_status__init
                     (Tethering__SetSensorStatus         *message)
{
  static Tethering__SetSensorStatus init_value = TETHERING__SET_SENSOR_STATUS__INIT;
  *message = init_value;
}
size_t tethering__set_sensor_status__get_packed_size
                     (const Tethering__SetSensorStatus *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__set_sensor_status__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__set_sensor_status__pack
                     (const Tethering__SetSensorStatus *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__set_sensor_status__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__set_sensor_status__pack_to_buffer
                     (const Tethering__SetSensorStatus *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__set_sensor_status__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__SetSensorStatus *
       tethering__set_sensor_status__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__SetSensorStatus *)
     protobuf_c_message_unpack (&tethering__set_sensor_status__descriptor,
                                allocator, len, data);
}
void   tethering__set_sensor_status__free_unpacked
                     (Tethering__SetSensorStatus *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__set_sensor_status__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__sensor_data__init
                     (Tethering__SensorData         *message)
{
  static Tethering__SensorData init_value = TETHERING__SENSOR_DATA__INIT;
  *message = init_value;
}
size_t tethering__sensor_data__get_packed_size
                     (const Tethering__SensorData *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__sensor_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__sensor_data__pack
                     (const Tethering__SensorData *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__sensor_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__sensor_data__pack_to_buffer
                     (const Tethering__SensorData *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__sensor_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__SensorData *
       tethering__sensor_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__SensorData *)
     protobuf_c_message_unpack (&tethering__sensor_data__descriptor,
                                allocator, len, data);
}
void   tethering__sensor_data__free_unpacked
                     (Tethering__SensorData *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__sensor_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__sensor_msg__init
                     (Tethering__SensorMsg         *message)
{
  static Tethering__SensorMsg init_value = TETHERING__SENSOR_MSG__INIT;
  *message = init_value;
}
size_t tethering__sensor_msg__get_packed_size
                     (const Tethering__SensorMsg *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__sensor_msg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__sensor_msg__pack
                     (const Tethering__SensorMsg *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__sensor_msg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__sensor_msg__pack_to_buffer
                     (const Tethering__SensorMsg *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__sensor_msg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__SensorMsg *
       tethering__sensor_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__SensorMsg *)
     protobuf_c_message_unpack (&tethering__sensor_msg__descriptor,
                                allocator, len, data);
}
void   tethering__sensor_msg__free_unpacked
                     (Tethering__SensorMsg *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__sensor_msg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__resolution__init
                     (Tethering__Resolution         *message)
{
  static Tethering__Resolution init_value = TETHERING__RESOLUTION__INIT;
  *message = init_value;
}
size_t tethering__resolution__get_packed_size
                     (const Tethering__Resolution *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__resolution__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__resolution__pack
                     (const Tethering__Resolution *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__resolution__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__resolution__pack_to_buffer
                     (const Tethering__Resolution *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__resolution__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__Resolution *
       tethering__resolution__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__Resolution *)
     protobuf_c_message_unpack (&tethering__resolution__descriptor,
                                allocator, len, data);
}
void   tethering__resolution__free_unpacked
                     (Tethering__Resolution *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__resolution__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__display_msg__init
                     (Tethering__DisplayMsg         *message)
{
  static Tethering__DisplayMsg init_value = TETHERING__DISPLAY_MSG__INIT;
  *message = init_value;
}
size_t tethering__display_msg__get_packed_size
                     (const Tethering__DisplayMsg *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__display_msg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__display_msg__pack
                     (const Tethering__DisplayMsg *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__display_msg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__display_msg__pack_to_buffer
                     (const Tethering__DisplayMsg *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__display_msg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__DisplayMsg *
       tethering__display_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__DisplayMsg *)
     protobuf_c_message_unpack (&tethering__display_msg__descriptor,
                                allocator, len, data);
}
void   tethering__display_msg__free_unpacked
                     (Tethering__DisplayMsg *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__display_msg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__touch_max_count__init
                     (Tethering__TouchMaxCount         *message)
{
  static Tethering__TouchMaxCount init_value = TETHERING__TOUCH_MAX_COUNT__INIT;
  *message = init_value;
}
size_t tethering__touch_max_count__get_packed_size
                     (const Tethering__TouchMaxCount *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_max_count__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__touch_max_count__pack
                     (const Tethering__TouchMaxCount *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_max_count__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__touch_max_count__pack_to_buffer
                     (const Tethering__TouchMaxCount *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_max_count__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__TouchMaxCount *
       tethering__touch_max_count__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__TouchMaxCount *)
     protobuf_c_message_unpack (&tethering__touch_max_count__descriptor,
                                allocator, len, data);
}
void   tethering__touch_max_count__free_unpacked
                     (Tethering__TouchMaxCount *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_max_count__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__touch_data__init
                     (Tethering__TouchData         *message)
{
  static Tethering__TouchData init_value = TETHERING__TOUCH_DATA__INIT;
  *message = init_value;
}
size_t tethering__touch_data__get_packed_size
                     (const Tethering__TouchData *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__touch_data__pack
                     (const Tethering__TouchData *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__touch_data__pack_to_buffer
                     (const Tethering__TouchData *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__TouchData *
       tethering__touch_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__TouchData *)
     protobuf_c_message_unpack (&tethering__touch_data__descriptor,
                                allocator, len, data);
}
void   tethering__touch_data__free_unpacked
                     (Tethering__TouchData *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__hwkey_msg__init
                     (Tethering__HWKeyMsg         *message)
{
  static Tethering__HWKeyMsg init_value = TETHERING__HWKEY_MSG__INIT;
  *message = init_value;
}
size_t tethering__hwkey_msg__get_packed_size
                     (const Tethering__HWKeyMsg *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hwkey_msg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__hwkey_msg__pack
                     (const Tethering__HWKeyMsg *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hwkey_msg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__hwkey_msg__pack_to_buffer
                     (const Tethering__HWKeyMsg *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hwkey_msg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__HWKeyMsg *
       tethering__hwkey_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__HWKeyMsg *)
     protobuf_c_message_unpack (&tethering__hwkey_msg__descriptor,
                                allocator, len, data);
}
void   tethering__hwkey_msg__free_unpacked
                     (Tethering__HWKeyMsg *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__hwkey_msg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__touch_msg__init
                     (Tethering__TouchMsg         *message)
{
  static Tethering__TouchMsg init_value = TETHERING__TOUCH_MSG__INIT;
  *message = init_value;
}
size_t tethering__touch_msg__get_packed_size
                     (const Tethering__TouchMsg *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_msg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__touch_msg__pack
                     (const Tethering__TouchMsg *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_msg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__touch_msg__pack_to_buffer
                     (const Tethering__TouchMsg *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_msg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__TouchMsg *
       tethering__touch_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__TouchMsg *)
     protobuf_c_message_unpack (&tethering__touch_msg__descriptor,
                                allocator, len, data);
}
void   tethering__touch_msg__free_unpacked
                     (Tethering__TouchMsg *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__touch_msg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   tethering__tethering_msg__init
                     (Tethering__TetheringMsg         *message)
{
  static Tethering__TetheringMsg init_value = TETHERING__TETHERING_MSG__INIT;
  *message = init_value;
}
size_t tethering__tethering_msg__get_packed_size
                     (const Tethering__TetheringMsg *message)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__tethering_msg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t tethering__tethering_msg__pack
                     (const Tethering__TetheringMsg *message,
                      uint8_t       *out)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__tethering_msg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t tethering__tethering_msg__pack_to_buffer
                     (const Tethering__TetheringMsg *message,
                      ProtobufCBuffer *buffer)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__tethering_msg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Tethering__TetheringMsg *
       tethering__tethering_msg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Tethering__TetheringMsg *)
     protobuf_c_message_unpack (&tethering__tethering_msg__descriptor,
                                allocator, len, data);
}
void   tethering__tethering_msg__free_unpacked
                     (Tethering__TetheringMsg *message,
                      ProtobufCAllocator *allocator)
{
  PROTOBUF_C_ASSERT (message->base.descriptor == &tethering__tethering_msg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor tethering__hand_shake_req__field_descriptors[1] =
{
  {
    "key",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__HandShakeReq, key),
    NULL,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__hand_shake_req__field_indices_by_name[] = {
  0,   /* field[0] = key */
};
static const ProtobufCIntRange tethering__hand_shake_req__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor tethering__hand_shake_req__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.HandShakeReq",
  "HandShakeReq",
  "Tethering__HandShakeReq",
  "tethering",
  sizeof(Tethering__HandShakeReq),
  1,
  tethering__hand_shake_req__field_descriptors,
  tethering__hand_shake_req__field_indices_by_name,
  1,  tethering__hand_shake_req__number_ranges,
  (ProtobufCMessageInit) tethering__hand_shake_req__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tethering__hand_shake_ans__field_descriptors[1] =
{
  {
    "result",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__HandShakeAns, result),
    &tethering__message_result__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__hand_shake_ans__field_indices_by_name[] = {
  0,   /* field[0] = result */
};
static const ProtobufCIntRange tethering__hand_shake_ans__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor tethering__hand_shake_ans__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.HandShakeAns",
  "HandShakeAns",
  "Tethering__HandShakeAns",
  "tethering",
  sizeof(Tethering__HandShakeAns),
  1,
  tethering__hand_shake_ans__field_descriptors,
  tethering__hand_shake_ans__field_indices_by_name,
  1,  tethering__hand_shake_ans__number_ranges,
  (ProtobufCMessageInit) tethering__hand_shake_ans__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tethering__emulator_state__field_descriptors[1] =
{
  {
    "state",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__EmulatorState, state),
    &tethering__connection_state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__emulator_state__field_indices_by_name[] = {
  0,   /* field[0] = state */
};
static const ProtobufCIntRange tethering__emulator_state__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor tethering__emulator_state__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.EmulatorState",
  "EmulatorState",
  "Tethering__EmulatorState",
  "tethering",
  sizeof(Tethering__EmulatorState),
  1,
  tethering__emulator_state__field_descriptors,
  tethering__emulator_state__field_indices_by_name,
  1,  tethering__emulator_state__number_ranges,
  (ProtobufCMessageInit) tethering__emulator_state__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tethering__app_state__field_descriptors[1] =
{
  {
    "state",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__AppState, state),
    &tethering__connection_state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__app_state__field_indices_by_name[] = {
  0,   /* field[0] = state */
};
static const ProtobufCIntRange tethering__app_state__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor tethering__app_state__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.AppState",
  "AppState",
  "Tethering__AppState",
  "tethering",
  sizeof(Tethering__AppState),
  1,
  tethering__app_state__field_descriptors,
  tethering__app_state__field_indices_by_name,
  1,  tethering__app_state__number_ranges,
  (ProtobufCMessageInit) tethering__app_state__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define tethering__start_req__field_descriptors NULL
#define tethering__start_req__field_indices_by_name NULL
#define tethering__start_req__number_ranges NULL
const ProtobufCMessageDescriptor tethering__start_req__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.StartReq",
  "StartReq",
  "Tethering__StartReq",
  "tethering",
  sizeof(Tethering__StartReq),
  0,
  tethering__start_req__field_descriptors,
  tethering__start_req__field_indices_by_name,
  0,  tethering__start_req__number_ranges,
  (ProtobufCMessageInit) tethering__start_req__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tethering__start_ans__field_descriptors[1] =
{
  {
    "result",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__StartAns, result),
    &tethering__message_result__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__start_ans__field_indices_by_name[] = {
  0,   /* field[0] = result */
};
static const ProtobufCIntRange tethering__start_ans__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor tethering__start_ans__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.StartAns",
  "StartAns",
  "Tethering__StartAns",
  "tethering",
  sizeof(Tethering__StartAns),
  1,
  tethering__start_ans__field_descriptors,
  tethering__start_ans__field_indices_by_name,
  1,  tethering__start_ans__number_ranges,
  (ProtobufCMessageInit) tethering__start_ans__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tethering__set_event_status__field_descriptors[2] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SetEventStatus, type),
    &tethering__event_type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "state",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SetEventStatus, state),
    &tethering__state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__set_event_status__field_indices_by_name[] = {
  1,   /* field[1] = state */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange tethering__set_event_status__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor tethering__set_event_status__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.SetEventStatus",
  "SetEventStatus",
  "Tethering__SetEventStatus",
  "tethering",
  sizeof(Tethering__SetEventStatus),
  2,
  tethering__set_event_status__field_descriptors,
  tethering__set_event_status__field_indices_by_name,
  1,  tethering__set_event_status__number_ranges,
  (ProtobufCMessageInit) tethering__set_event_status__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue tethering__event_msg__type__enum_values_by_number[4] =
{
  { "START_REQ", "TETHERING__EVENT_MSG__TYPE__START_REQ", 2 },
  { "START_ANS", "TETHERING__EVENT_MSG__TYPE__START_ANS", 3 },
  { "TERMINATE", "TETHERING__EVENT_MSG__TYPE__TERMINATE", 4 },
  { "EVENT_STATUS", "TETHERING__EVENT_MSG__TYPE__EVENT_STATUS", 5 },
};
static const ProtobufCIntRange tethering__event_msg__type__value_ranges[] = {
{2, 0},{0, 4}
};
const ProtobufCEnumValueIndex tethering__event_msg__type__enum_values_by_name[4] =
{
  { "EVENT_STATUS", 3 },
  { "START_ANS", 1 },
  { "START_REQ", 0 },
  { "TERMINATE", 2 },
};
const ProtobufCEnumDescriptor tethering__event_msg__type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.EventMsg.TYPE",
  "TYPE",
  "Tethering__EventMsg__TYPE",
  "tethering",
  4,
  tethering__event_msg__type__enum_values_by_number,
  4,
  tethering__event_msg__type__enum_values_by_name,
  1,
  tethering__event_msg__type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCFieldDescriptor tethering__event_msg__field_descriptors[5] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__EventMsg, type),
    &tethering__event_msg__type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startReq",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__EventMsg, startreq),
    &tethering__start_req__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startAns",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__EventMsg, startans),
    &tethering__start_ans__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "terminate",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__EventMsg, terminate),
    &tethering__event_terminate__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "setStatus",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__EventMsg, setstatus),
    &tethering__set_event_status__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__event_msg__field_indices_by_name[] = {
  4,   /* field[4] = setStatus */
  2,   /* field[2] = startAns */
  1,   /* field[1] = startReq */
  3,   /* field[3] = terminate */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange tethering__event_msg__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor tethering__event_msg__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.EventMsg",
  "EventMsg",
  "Tethering__EventMsg",
  "tethering",
  sizeof(Tethering__EventMsg),
  5,
  tethering__event_msg__field_descriptors,
  tethering__event_msg__field_indices_by_name,
  1,  tethering__event_msg__number_ranges,
  (ProtobufCMessageInit) tethering__event_msg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
#define tethering__event_terminate__field_descriptors NULL
#define tethering__event_terminate__field_indices_by_name NULL
#define tethering__event_terminate__number_ranges NULL
const ProtobufCMessageDescriptor tethering__event_terminate__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.EventTerminate",
  "EventTerminate",
  "Tethering__EventTerminate",
  "tethering",
  sizeof(Tethering__EventTerminate),
  0,
  tethering__event_terminate__field_descriptors,
  tethering__event_terminate__field_indices_by_name,
  0,  tethering__event_terminate__number_ranges,
  (ProtobufCMessageInit) tethering__event_terminate__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tethering__set_sensor_status__field_descriptors[2] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SetSensorStatus, type),
    &tethering__sensor_type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "state",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SetSensorStatus, state),
    &tethering__state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__set_sensor_status__field_indices_by_name[] = {
  1,   /* field[1] = state */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange tethering__set_sensor_status__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor tethering__set_sensor_status__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.SetSensorStatus",
  "SetSensorStatus",
  "Tethering__SetSensorStatus",
  "tethering",
  sizeof(Tethering__SetSensorStatus),
  2,
  tethering__set_sensor_status__field_descriptors,
  tethering__set_sensor_status__field_indices_by_name,
  1,  tethering__set_sensor_status__number_ranges,
  (ProtobufCMessageInit) tethering__set_sensor_status__init,
  NULL,NULL,NULL    /* reserved[123] */
};
char tethering__sensor_data__x__default_value[] = "0";
char tethering__sensor_data__y__default_value[] = "0";
char tethering__sensor_data__z__default_value[] = "0";
static const ProtobufCFieldDescriptor tethering__sensor_data__field_descriptors[4] =
{
  {
    "sensor",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SensorData, sensor),
    &tethering__sensor_type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "x",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SensorData, x),
    NULL,
    &tethering__sensor_data__x__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "y",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SensorData, y),
    NULL,
    &tethering__sensor_data__y__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "z",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SensorData, z),
    NULL,
    &tethering__sensor_data__z__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__sensor_data__field_indices_by_name[] = {
  0,   /* field[0] = sensor */
  1,   /* field[1] = x */
  2,   /* field[2] = y */
  3,   /* field[3] = z */
};
static const ProtobufCIntRange tethering__sensor_data__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor tethering__sensor_data__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.SensorData",
  "SensorData",
  "Tethering__SensorData",
  "tethering",
  sizeof(Tethering__SensorData),
  4,
  tethering__sensor_data__field_descriptors,
  tethering__sensor_data__field_indices_by_name,
  1,  tethering__sensor_data__number_ranges,
  (ProtobufCMessageInit) tethering__sensor_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue tethering__sensor_msg__type__enum_values_by_number[5] =
{
  { "START_REQ", "TETHERING__SENSOR_MSG__TYPE__START_REQ", 2 },
  { "START_ANS", "TETHERING__SENSOR_MSG__TYPE__START_ANS", 3 },
  { "TERMINATE", "TETHERING__SENSOR_MSG__TYPE__TERMINATE", 4 },
  { "SENSOR_STATUS", "TETHERING__SENSOR_MSG__TYPE__SENSOR_STATUS", 5 },
  { "SENSOR_DATA", "TETHERING__SENSOR_MSG__TYPE__SENSOR_DATA", 6 },
};
static const ProtobufCIntRange tethering__sensor_msg__type__value_ranges[] = {
{2, 0},{0, 5}
};
const ProtobufCEnumValueIndex tethering__sensor_msg__type__enum_values_by_name[5] =
{
  { "SENSOR_DATA", 4 },
  { "SENSOR_STATUS", 3 },
  { "START_ANS", 1 },
  { "START_REQ", 0 },
  { "TERMINATE", 2 },
};
const ProtobufCEnumDescriptor tethering__sensor_msg__type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.SensorMsg.Type",
  "Type",
  "Tethering__SensorMsg__Type",
  "tethering",
  5,
  tethering__sensor_msg__type__enum_values_by_number,
  5,
  tethering__sensor_msg__type__enum_values_by_name,
  1,
  tethering__sensor_msg__type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCFieldDescriptor tethering__sensor_msg__field_descriptors[6] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SensorMsg, type),
    &tethering__sensor_msg__type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startReq",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SensorMsg, startreq),
    &tethering__start_req__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startAns",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SensorMsg, startans),
    &tethering__start_ans__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "terminate",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SensorMsg, terminate),
    &tethering__event_terminate__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "setStatus",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SensorMsg, setstatus),
    &tethering__set_sensor_status__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "data",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__SensorMsg, data),
    &tethering__sensor_data__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__sensor_msg__field_indices_by_name[] = {
  5,   /* field[5] = data */
  4,   /* field[4] = setStatus */
  2,   /* field[2] = startAns */
  1,   /* field[1] = startReq */
  3,   /* field[3] = terminate */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange tethering__sensor_msg__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor tethering__sensor_msg__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.SensorMsg",
  "SensorMsg",
  "Tethering__SensorMsg",
  "tethering",
  sizeof(Tethering__SensorMsg),
  6,
  tethering__sensor_msg__field_descriptors,
  tethering__sensor_msg__field_indices_by_name,
  1,  tethering__sensor_msg__number_ranges,
  (ProtobufCMessageInit) tethering__sensor_msg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tethering__resolution__field_descriptors[2] =
{
  {
    "width",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__Resolution, width),
    NULL,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "height",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_INT32,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__Resolution, height),
    NULL,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__resolution__field_indices_by_name[] = {
  1,   /* field[1] = height */
  0,   /* field[0] = width */
};
static const ProtobufCIntRange tethering__resolution__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor tethering__resolution__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.Resolution",
  "Resolution",
  "Tethering__Resolution",
  "tethering",
  sizeof(Tethering__Resolution),
  2,
  tethering__resolution__field_descriptors,
  tethering__resolution__field_indices_by_name,
  1,  tethering__resolution__number_ranges,
  (ProtobufCMessageInit) tethering__resolution__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tethering__display_msg__field_descriptors[2] =
{
  {
    "frameRate",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    PROTOBUF_C_OFFSETOF(Tethering__DisplayMsg, has_framerate),
    PROTOBUF_C_OFFSETOF(Tethering__DisplayMsg, framerate),
    NULL,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "imageData",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BYTES,
    PROTOBUF_C_OFFSETOF(Tethering__DisplayMsg, has_imagedata),
    PROTOBUF_C_OFFSETOF(Tethering__DisplayMsg, imagedata),
    NULL,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__display_msg__field_indices_by_name[] = {
  0,   /* field[0] = frameRate */
  1,   /* field[1] = imageData */
};
static const ProtobufCIntRange tethering__display_msg__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor tethering__display_msg__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.DisplayMsg",
  "DisplayMsg",
  "Tethering__DisplayMsg",
  "tethering",
  sizeof(Tethering__DisplayMsg),
  2,
  tethering__display_msg__field_descriptors,
  tethering__display_msg__field_indices_by_name,
  1,  tethering__display_msg__number_ranges,
  (ProtobufCMessageInit) tethering__display_msg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const int32_t tethering__touch_max_count__max__default_value = 10;
static const ProtobufCFieldDescriptor tethering__touch_max_count__field_descriptors[1] =
{
  {
    "max",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    PROTOBUF_C_OFFSETOF(Tethering__TouchMaxCount, has_max),
    PROTOBUF_C_OFFSETOF(Tethering__TouchMaxCount, max),
    NULL,
    &tethering__touch_max_count__max__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__touch_max_count__field_indices_by_name[] = {
  0,   /* field[0] = max */
};
static const ProtobufCIntRange tethering__touch_max_count__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor tethering__touch_max_count__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.TouchMaxCount",
  "TouchMaxCount",
  "Tethering__TouchMaxCount",
  "tethering",
  sizeof(Tethering__TouchMaxCount),
  1,
  tethering__touch_max_count__field_descriptors,
  tethering__touch_max_count__field_indices_by_name,
  1,  tethering__touch_max_count__number_ranges,
  (ProtobufCMessageInit) tethering__touch_max_count__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const int32_t tethering__touch_data__index__default_value = 0;
static const float tethering__touch_data__x_point__default_value = 0;
static const float tethering__touch_data__y_point__default_value = 0;
static const ProtobufCFieldDescriptor tethering__touch_data__field_descriptors[4] =
{
  {
    "index",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_INT32,
    PROTOBUF_C_OFFSETOF(Tethering__TouchData, has_index),
    PROTOBUF_C_OFFSETOF(Tethering__TouchData, index),
    NULL,
    &tethering__touch_data__index__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "xPoint",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    PROTOBUF_C_OFFSETOF(Tethering__TouchData, has_xpoint),
    PROTOBUF_C_OFFSETOF(Tethering__TouchData, xpoint),
    NULL,
    &tethering__touch_data__x_point__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "yPoint",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    PROTOBUF_C_OFFSETOF(Tethering__TouchData, has_ypoint),
    PROTOBUF_C_OFFSETOF(Tethering__TouchData, ypoint),
    NULL,
    &tethering__touch_data__y_point__default_value,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "state",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    PROTOBUF_C_OFFSETOF(Tethering__TouchData, has_state),
    PROTOBUF_C_OFFSETOF(Tethering__TouchData, state),
    &tethering__touch_state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__touch_data__field_indices_by_name[] = {
  0,   /* field[0] = index */
  3,   /* field[3] = state */
  1,   /* field[1] = xPoint */
  2,   /* field[2] = yPoint */
};
static const ProtobufCIntRange tethering__touch_data__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor tethering__touch_data__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.TouchData",
  "TouchData",
  "Tethering__TouchData",
  "tethering",
  sizeof(Tethering__TouchData),
  4,
  tethering__touch_data__field_descriptors,
  tethering__touch_data__field_indices_by_name,
  1,  tethering__touch_data__number_ranges,
  (ProtobufCMessageInit) tethering__touch_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor tethering__hwkey_msg__field_descriptors[1] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__HWKeyMsg, type),
    &tethering__hwkey_type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__hwkey_msg__field_indices_by_name[] = {
  0,   /* field[0] = type */
};
static const ProtobufCIntRange tethering__hwkey_msg__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor tethering__hwkey_msg__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.HWKeyMsg",
  "HWKeyMsg",
  "Tethering__HWKeyMsg",
  "tethering",
  sizeof(Tethering__HWKeyMsg),
  1,
  tethering__hwkey_msg__field_descriptors,
  tethering__hwkey_msg__field_indices_by_name,
  1,  tethering__hwkey_msg__number_ranges,
  (ProtobufCMessageInit) tethering__hwkey_msg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue tethering__touch_msg__type__enum_values_by_number[8] =
{
  { "START_REQ", "TETHERING__TOUCH_MSG__TYPE__START_REQ", 2 },
  { "START_ANS", "TETHERING__TOUCH_MSG__TYPE__START_ANS", 3 },
  { "TERMINATE", "TETHERING__TOUCH_MSG__TYPE__TERMINATE", 4 },
  { "MAX_COUNT", "TETHERING__TOUCH_MSG__TYPE__MAX_COUNT", 5 },
  { "TOUCH_DATA", "TETHERING__TOUCH_MSG__TYPE__TOUCH_DATA", 6 },
  { "RESOLUTION", "TETHERING__TOUCH_MSG__TYPE__RESOLUTION", 7 },
  { "DISPLAY_MSG", "TETHERING__TOUCH_MSG__TYPE__DISPLAY_MSG", 8 },
  { "HWKEY_MSG", "TETHERING__TOUCH_MSG__TYPE__HWKEY_MSG", 9 },
};
static const ProtobufCIntRange tethering__touch_msg__type__value_ranges[] = {
{2, 0},{0, 8}
};
const ProtobufCEnumValueIndex tethering__touch_msg__type__enum_values_by_name[8] =
{
  { "DISPLAY_MSG", 6 },
  { "HWKEY_MSG", 7 },
  { "MAX_COUNT", 3 },
  { "RESOLUTION", 5 },
  { "START_ANS", 1 },
  { "START_REQ", 0 },
  { "TERMINATE", 2 },
  { "TOUCH_DATA", 4 },
};
const ProtobufCEnumDescriptor tethering__touch_msg__type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.TouchMsg.Type",
  "Type",
  "Tethering__TouchMsg__Type",
  "tethering",
  8,
  tethering__touch_msg__type__enum_values_by_number,
  8,
  tethering__touch_msg__type__enum_values_by_name,
  1,
  tethering__touch_msg__type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCFieldDescriptor tethering__touch_msg__field_descriptors[9] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TouchMsg, type),
    &tethering__touch_msg__type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startReq",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TouchMsg, startreq),
    &tethering__start_req__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "startAns",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TouchMsg, startans),
    &tethering__start_ans__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "terminate",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TouchMsg, terminate),
    &tethering__event_terminate__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "maxCount",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TouchMsg, maxcount),
    &tethering__touch_max_count__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "touchData",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TouchMsg, touchdata),
    &tethering__touch_data__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "resolution",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TouchMsg, resolution),
    &tethering__resolution__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "display",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TouchMsg, display),
    &tethering__display_msg__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "hwkey",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TouchMsg, hwkey),
    &tethering__hwkey_msg__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__touch_msg__field_indices_by_name[] = {
  7,   /* field[7] = display */
  8,   /* field[8] = hwkey */
  4,   /* field[4] = maxCount */
  6,   /* field[6] = resolution */
  2,   /* field[2] = startAns */
  1,   /* field[1] = startReq */
  3,   /* field[3] = terminate */
  5,   /* field[5] = touchData */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange tethering__touch_msg__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 9 }
};
const ProtobufCMessageDescriptor tethering__touch_msg__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.TouchMsg",
  "TouchMsg",
  "Tethering__TouchMsg",
  "tethering",
  sizeof(Tethering__TouchMsg),
  9,
  tethering__touch_msg__field_descriptors,
  tethering__touch_msg__field_indices_by_name,
  1,  tethering__touch_msg__number_ranges,
  (ProtobufCMessageInit) tethering__touch_msg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue tethering__tethering_msg__type__enum_values_by_number[7] =
{
  { "HANDSHAKE_REQ", "TETHERING__TETHERING_MSG__TYPE__HANDSHAKE_REQ", 2 },
  { "HANDSHAKE_ANS", "TETHERING__TETHERING_MSG__TYPE__HANDSHAKE_ANS", 3 },
  { "EMUL_STATE", "TETHERING__TETHERING_MSG__TYPE__EMUL_STATE", 4 },
  { "APP_STATE", "TETHERING__TETHERING_MSG__TYPE__APP_STATE", 5 },
  { "EVENT_MSG", "TETHERING__TETHERING_MSG__TYPE__EVENT_MSG", 6 },
  { "SENSOR_MSG", "TETHERING__TETHERING_MSG__TYPE__SENSOR_MSG", 7 },
  { "TOUCH_MSG", "TETHERING__TETHERING_MSG__TYPE__TOUCH_MSG", 8 },
};
static const ProtobufCIntRange tethering__tethering_msg__type__value_ranges[] = {
{2, 0},{0, 7}
};
const ProtobufCEnumValueIndex tethering__tethering_msg__type__enum_values_by_name[7] =
{
  { "APP_STATE", 3 },
  { "EMUL_STATE", 2 },
  { "EVENT_MSG", 4 },
  { "HANDSHAKE_ANS", 1 },
  { "HANDSHAKE_REQ", 0 },
  { "SENSOR_MSG", 5 },
  { "TOUCH_MSG", 6 },
};
const ProtobufCEnumDescriptor tethering__tethering_msg__type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.TetheringMsg.Type",
  "Type",
  "Tethering__TetheringMsg__Type",
  "tethering",
  7,
  tethering__tethering_msg__type__enum_values_by_number,
  7,
  tethering__tethering_msg__type__enum_values_by_name,
  1,
  tethering__tethering_msg__type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCFieldDescriptor tethering__tethering_msg__field_descriptors[8] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TetheringMsg, type),
    &tethering__tethering_msg__type__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "handShakeReq",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TetheringMsg, handshakereq),
    &tethering__hand_shake_req__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "handShakeAns",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TetheringMsg, handshakeans),
    &tethering__hand_shake_ans__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "emulState",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TetheringMsg, emulstate),
    &tethering__emulator_state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "appState",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TetheringMsg, appstate),
    &tethering__app_state__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eventMsg",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TetheringMsg, eventmsg),
    &tethering__event_msg__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sensorMsg",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TetheringMsg, sensormsg),
    &tethering__sensor_msg__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "touchMsg",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    PROTOBUF_C_OFFSETOF(Tethering__TetheringMsg, touchmsg),
    &tethering__touch_msg__descriptor,
    NULL,
    0,            /* packed */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned tethering__tethering_msg__field_indices_by_name[] = {
  4,   /* field[4] = appState */
  3,   /* field[3] = emulState */
  5,   /* field[5] = eventMsg */
  2,   /* field[2] = handShakeAns */
  1,   /* field[1] = handShakeReq */
  6,   /* field[6] = sensorMsg */
  7,   /* field[7] = touchMsg */
  0,   /* field[0] = type */
};
static const ProtobufCIntRange tethering__tethering_msg__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 8 }
};
const ProtobufCMessageDescriptor tethering__tethering_msg__descriptor =
{
  PROTOBUF_C_MESSAGE_DESCRIPTOR_MAGIC,
  "tethering.TetheringMsg",
  "TetheringMsg",
  "Tethering__TetheringMsg",
  "tethering",
  sizeof(Tethering__TetheringMsg),
  8,
  tethering__tethering_msg__field_descriptors,
  tethering__tethering_msg__field_indices_by_name,
  1,  tethering__tethering_msg__number_ranges,
  (ProtobufCMessageInit) tethering__tethering_msg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue tethering__message_result__enum_values_by_number[3] =
{
  { "SUCCESS", "TETHERING__MESSAGE_RESULT__SUCCESS", 1 },
  { "FAILURE", "TETHERING__MESSAGE_RESULT__FAILURE", 2 },
  { "CANCEL", "TETHERING__MESSAGE_RESULT__CANCEL", 3 },
};
static const ProtobufCIntRange tethering__message_result__value_ranges[] = {
{1, 0},{0, 3}
};
const ProtobufCEnumValueIndex tethering__message_result__enum_values_by_name[3] =
{
  { "CANCEL", 2 },
  { "FAILURE", 1 },
  { "SUCCESS", 0 },
};
const ProtobufCEnumDescriptor tethering__message_result__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.MessageResult",
  "MessageResult",
  "Tethering__MessageResult",
  "tethering",
  3,
  tethering__message_result__enum_values_by_number,
  3,
  tethering__message_result__enum_values_by_name,
  1,
  tethering__message_result__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue tethering__connection_state__enum_values_by_number[3] =
{
  { "CONNECTED", "TETHERING__CONNECTION_STATE__CONNECTED", 1 },
  { "DISCONNECTED", "TETHERING__CONNECTION_STATE__DISCONNECTED", 2 },
  { "TERMINATED", "TETHERING__CONNECTION_STATE__TERMINATED", 3 },
};
static const ProtobufCIntRange tethering__connection_state__value_ranges[] = {
{1, 0},{0, 3}
};
const ProtobufCEnumValueIndex tethering__connection_state__enum_values_by_name[3] =
{
  { "CONNECTED", 0 },
  { "DISCONNECTED", 1 },
  { "TERMINATED", 2 },
};
const ProtobufCEnumDescriptor tethering__connection_state__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.ConnectionState",
  "ConnectionState",
  "Tethering__ConnectionState",
  "tethering",
  3,
  tethering__connection_state__enum_values_by_number,
  3,
  tethering__connection_state__enum_values_by_name,
  1,
  tethering__connection_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue tethering__event_type__enum_values_by_number[2] =
{
  { "SENSOR", "TETHERING__EVENT_TYPE__SENSOR", 1 },
  { "TOUCH", "TETHERING__EVENT_TYPE__TOUCH", 2 },
};
static const ProtobufCIntRange tethering__event_type__value_ranges[] = {
{1, 0},{0, 2}
};
const ProtobufCEnumValueIndex tethering__event_type__enum_values_by_name[2] =
{
  { "SENSOR", 0 },
  { "TOUCH", 1 },
};
const ProtobufCEnumDescriptor tethering__event_type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.EventType",
  "EventType",
  "Tethering__EventType",
  "tethering",
  2,
  tethering__event_type__enum_values_by_number,
  2,
  tethering__event_type__enum_values_by_name,
  1,
  tethering__event_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue tethering__state__enum_values_by_number[2] =
{
  { "ENABLED", "TETHERING__STATE__ENABLED", 1 },
  { "DISABLED", "TETHERING__STATE__DISABLED", 2 },
};
static const ProtobufCIntRange tethering__state__value_ranges[] = {
{1, 0},{0, 2}
};
const ProtobufCEnumValueIndex tethering__state__enum_values_by_name[2] =
{
  { "DISABLED", 1 },
  { "ENABLED", 0 },
};
const ProtobufCEnumDescriptor tethering__state__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.State",
  "State",
  "Tethering__State",
  "tethering",
  2,
  tethering__state__enum_values_by_number,
  2,
  tethering__state__enum_values_by_name,
  1,
  tethering__state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue tethering__sensor_type__enum_values_by_number[5] =
{
  { "ACCEL", "TETHERING__SENSOR_TYPE__ACCEL", 1 },
  { "MAGNETIC", "TETHERING__SENSOR_TYPE__MAGNETIC", 2 },
  { "GYROSCOPE", "TETHERING__SENSOR_TYPE__GYROSCOPE", 3 },
  { "PROXIMITY", "TETHERING__SENSOR_TYPE__PROXIMITY", 4 },
  { "LIGHT", "TETHERING__SENSOR_TYPE__LIGHT", 5 },
};
static const ProtobufCIntRange tethering__sensor_type__value_ranges[] = {
{1, 0},{0, 5}
};
const ProtobufCEnumValueIndex tethering__sensor_type__enum_values_by_name[5] =
{
  { "ACCEL", 0 },
  { "GYROSCOPE", 2 },
  { "LIGHT", 4 },
  { "MAGNETIC", 1 },
  { "PROXIMITY", 3 },
};
const ProtobufCEnumDescriptor tethering__sensor_type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.SensorType",
  "SensorType",
  "Tethering__SensorType",
  "tethering",
  5,
  tethering__sensor_type__enum_values_by_number,
  5,
  tethering__sensor_type__enum_values_by_name,
  1,
  tethering__sensor_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue tethering__touch_state__enum_values_by_number[2] =
{
  { "PRESSED", "TETHERING__TOUCH_STATE__PRESSED", 1 },
  { "RELEASED", "TETHERING__TOUCH_STATE__RELEASED", 2 },
};
static const ProtobufCIntRange tethering__touch_state__value_ranges[] = {
{1, 0},{0, 2}
};
const ProtobufCEnumValueIndex tethering__touch_state__enum_values_by_name[2] =
{
  { "PRESSED", 0 },
  { "RELEASED", 1 },
};
const ProtobufCEnumDescriptor tethering__touch_state__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.TouchState",
  "TouchState",
  "Tethering__TouchState",
  "tethering",
  2,
  tethering__touch_state__enum_values_by_number,
  2,
  tethering__touch_state__enum_values_by_name,
  1,
  tethering__touch_state__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue tethering__hwkey_type__enum_values_by_number[6] =
{
  { "MENU", "TETHERING__HWKEY_TYPE__MENU", 1 },
  { "HOME", "TETHERING__HWKEY_TYPE__HOME", 2 },
  { "BACK", "TETHERING__HWKEY_TYPE__BACK", 3 },
  { "POWER", "TETHERING__HWKEY_TYPE__POWER", 4 },
  { "VOLUME_UP", "TETHERING__HWKEY_TYPE__VOLUME_UP", 5 },
  { "VOLUME_DOWN", "TETHERING__HWKEY_TYPE__VOLUME_DOWN", 6 },
};
static const ProtobufCIntRange tethering__hwkey_type__value_ranges[] = {
{1, 0},{0, 6}
};
const ProtobufCEnumValueIndex tethering__hwkey_type__enum_values_by_name[6] =
{
  { "BACK", 2 },
  { "HOME", 1 },
  { "MENU", 0 },
  { "POWER", 3 },
  { "VOLUME_DOWN", 5 },
  { "VOLUME_UP", 4 },
};
const ProtobufCEnumDescriptor tethering__hwkey_type__descriptor =
{
  PROTOBUF_C_ENUM_DESCRIPTOR_MAGIC,
  "tethering.HWKeyType",
  "HWKeyType",
  "Tethering__HWKeyType",
  "tethering",
  6,
  tethering__hwkey_type__enum_values_by_number,
  6,
  tethering__hwkey_type__enum_values_by_name,
  1,
  tethering__hwkey_type__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
