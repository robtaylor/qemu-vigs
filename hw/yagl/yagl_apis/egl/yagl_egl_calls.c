/*
 * yagl
 *
 * Copyright (c) 2000 - 2013 Samsung Electronics Co., Ltd. All rights reserved.
 *
 * Contact:
 * Stanislav Vorobiov <s.vorobiov@samsung.com>
 * Jinhyung Jo <jinhyung.jo@samsung.com>
 * YeongKyoon Lee <yeongkyoon.lee@samsung.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Contributors:
 * - S-Core Co., Ltd
 *
 */

/*
 * Generated by gen-yagl-calls.py, do not modify!
 */
#include "yagl_egl_calls.h"
#include "yagl_host_egl_calls.h"
#include "yagl_transport_egl.h"
#include "yagl_thread.h"
#include "yagl_process.h"
#include "yagl_log.h"

/*
 * eglGetDisplay dispatcher. id = 1
 */
static void yagl_func_eglGetDisplay(struct yagl_transport *t)
{
    uint32_t display_id;
    EGLint *error;
    yagl_host_handle *retval;
    display_id = yagl_transport_get_out_uint32_t(t);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT2(eglGetDisplay, uint32_t, void*, display_id, error);
    *retval = yagl_host_eglGetDisplay(display_id, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(yagl_host_handle, *retval);
}

/*
 * eglInitialize dispatcher. id = 2
 */
static void yagl_func_eglInitialize(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    EGLint *major;
    EGLint *minor;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    yagl_transport_get_in_arg(t, (void**)&major);
    yagl_transport_get_in_arg(t, (void**)&minor);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT4(eglInitialize, yagl_host_handle, void*, void*, void*, dpy, major, minor, error);
    *retval = yagl_host_eglInitialize(dpy, major, minor, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglTerminate dispatcher. id = 3
 */
static void yagl_func_eglTerminate(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT2(eglTerminate, yagl_host_handle, void*, dpy, error);
    *retval = yagl_host_eglTerminate(dpy, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglGetConfigs dispatcher. id = 4
 */
static void yagl_func_eglGetConfigs(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle *configs;
    int32_t configs_maxcount;
    int32_t *configs_count;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    yagl_transport_get_in_array(t, sizeof(yagl_host_handle), (void**)&configs, &configs_maxcount, &configs_count);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT3(eglGetConfigs, yagl_host_handle, void*, void*, dpy, configs, error);
    *configs_count = 0;
    *retval = yagl_host_eglGetConfigs(dpy, configs, configs_maxcount, configs_count, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglChooseConfig dispatcher. id = 5
 */
static void yagl_func_eglChooseConfig(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    const EGLint *attrib_list;
    int32_t attrib_list_count;
    yagl_host_handle *configs;
    int32_t configs_maxcount;
    int32_t *configs_count;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    yagl_transport_get_out_array(t, sizeof(EGLint), (const void**)&attrib_list, &attrib_list_count);
    yagl_transport_get_in_array(t, sizeof(yagl_host_handle), (void**)&configs, &configs_maxcount, &configs_count);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT4(eglChooseConfig, yagl_host_handle, void*, void*, void*, dpy, attrib_list, configs, error);
    *configs_count = 0;
    *retval = yagl_host_eglChooseConfig(dpy, attrib_list, attrib_list_count, configs, configs_maxcount, configs_count, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglGetConfigAttrib dispatcher. id = 6
 */
static void yagl_func_eglGetConfigAttrib(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle config;
    EGLint attribute;
    EGLint *value;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    config = yagl_transport_get_out_yagl_host_handle(t);
    attribute = yagl_transport_get_out_EGLint(t);
    yagl_transport_get_in_arg(t, (void**)&value);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT5(eglGetConfigAttrib, yagl_host_handle, yagl_host_handle, EGLint, void*, void*, dpy, config, attribute, value, error);
    *retval = yagl_host_eglGetConfigAttrib(dpy, config, attribute, value, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglDestroySurface dispatcher. id = 7
 */
static void yagl_func_eglDestroySurface(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle surface;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    surface = yagl_transport_get_out_yagl_host_handle(t);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT3(eglDestroySurface, yagl_host_handle, yagl_host_handle, void*, dpy, surface, error);
    *retval = yagl_host_eglDestroySurface(dpy, surface, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglQuerySurface dispatcher. id = 8
 */
static void yagl_func_eglQuerySurface(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle surface;
    EGLint attribute;
    EGLint *value;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    surface = yagl_transport_get_out_yagl_host_handle(t);
    attribute = yagl_transport_get_out_EGLint(t);
    yagl_transport_get_in_arg(t, (void**)&value);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT5(eglQuerySurface, yagl_host_handle, yagl_host_handle, EGLint, void*, void*, dpy, surface, attribute, value, error);
    *retval = yagl_host_eglQuerySurface(dpy, surface, attribute, value, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglBindAPI dispatcher. id = 9
 */
static void yagl_func_eglBindAPI(struct yagl_transport *t)
{
    EGLenum api;
    api = yagl_transport_get_out_EGLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(eglBindAPI, EGLenum, api);
    (void)yagl_host_eglBindAPI(api);
    YAGL_LOG_FUNC_EXIT(NULL);
}

/*
 * eglWaitClient dispatcher. id = 10
 */
static void yagl_func_eglWaitClient(struct yagl_transport *t)
{
    YAGL_LOG_FUNC_ENTER_SPLIT0(eglWaitClient);
    (void)yagl_host_eglWaitClient();
    YAGL_LOG_FUNC_EXIT(NULL);
}

/*
 * eglReleaseThread dispatcher. id = 11
 */
static void yagl_func_eglReleaseThread(struct yagl_transport *t)
{
    EGLint *error;
    EGLBoolean *retval;
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT1(eglReleaseThread, void*, error);
    *retval = yagl_host_eglReleaseThread(error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglSurfaceAttrib dispatcher. id = 12
 */
static void yagl_func_eglSurfaceAttrib(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle surface;
    EGLint attribute;
    EGLint value;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    surface = yagl_transport_get_out_yagl_host_handle(t);
    attribute = yagl_transport_get_out_EGLint(t);
    value = yagl_transport_get_out_EGLint(t);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT5(eglSurfaceAttrib, yagl_host_handle, yagl_host_handle, EGLint, EGLint, void*, dpy, surface, attribute, value, error);
    *retval = yagl_host_eglSurfaceAttrib(dpy, surface, attribute, value, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglCreateContext dispatcher. id = 13
 */
static void yagl_func_eglCreateContext(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle config;
    yagl_host_handle share_context;
    const EGLint *attrib_list;
    int32_t attrib_list_count;
    EGLint *error;
    yagl_host_handle *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    config = yagl_transport_get_out_yagl_host_handle(t);
    share_context = yagl_transport_get_out_yagl_host_handle(t);
    yagl_transport_get_out_array(t, sizeof(EGLint), (const void**)&attrib_list, &attrib_list_count);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT5(eglCreateContext, yagl_host_handle, yagl_host_handle, yagl_host_handle, void*, void*, dpy, config, share_context, attrib_list, error);
    *retval = yagl_host_eglCreateContext(dpy, config, share_context, attrib_list, attrib_list_count, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(yagl_host_handle, *retval);
}

/*
 * eglDestroyContext dispatcher. id = 14
 */
static void yagl_func_eglDestroyContext(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle ctx;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    ctx = yagl_transport_get_out_yagl_host_handle(t);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT3(eglDestroyContext, yagl_host_handle, yagl_host_handle, void*, dpy, ctx, error);
    *retval = yagl_host_eglDestroyContext(dpy, ctx, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglMakeCurrent dispatcher. id = 15
 */
static void yagl_func_eglMakeCurrent(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle draw;
    yagl_host_handle read;
    yagl_host_handle ctx;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    draw = yagl_transport_get_out_yagl_host_handle(t);
    read = yagl_transport_get_out_yagl_host_handle(t);
    ctx = yagl_transport_get_out_yagl_host_handle(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(eglMakeCurrent, yagl_host_handle, yagl_host_handle, yagl_host_handle, yagl_host_handle, dpy, draw, read, ctx);
    (void)yagl_host_eglMakeCurrent(dpy, draw, read, ctx);
    YAGL_LOG_FUNC_EXIT(NULL);
}

/*
 * eglQueryContext dispatcher. id = 16
 */
static void yagl_func_eglQueryContext(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle ctx;
    EGLint attribute;
    EGLint *value;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    ctx = yagl_transport_get_out_yagl_host_handle(t);
    attribute = yagl_transport_get_out_EGLint(t);
    yagl_transport_get_in_arg(t, (void**)&value);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT5(eglQueryContext, yagl_host_handle, yagl_host_handle, EGLint, void*, void*, dpy, ctx, attribute, value, error);
    *retval = yagl_host_eglQueryContext(dpy, ctx, attribute, value, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglSwapBuffers dispatcher. id = 17
 */
static void yagl_func_eglSwapBuffers(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle surface;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    surface = yagl_transport_get_out_yagl_host_handle(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(eglSwapBuffers, yagl_host_handle, yagl_host_handle, dpy, surface);
    (void)yagl_host_eglSwapBuffers(dpy, surface);
    YAGL_LOG_FUNC_EXIT(NULL);
}

/*
 * eglCopyBuffers dispatcher. id = 18
 */
static void yagl_func_eglCopyBuffers(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle surface;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    surface = yagl_transport_get_out_yagl_host_handle(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(eglCopyBuffers, yagl_host_handle, yagl_host_handle, dpy, surface);
    (void)yagl_host_eglCopyBuffers(dpy, surface);
    YAGL_LOG_FUNC_EXIT(NULL);
}

/*
 * eglCreateWindowSurfaceOffscreenYAGL dispatcher. id = 19
 */
static void yagl_func_eglCreateWindowSurfaceOffscreenYAGL(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle config;
    uint32_t width;
    uint32_t height;
    uint32_t bpp;
    target_ulong pixels;
    const EGLint *attrib_list;
    int32_t attrib_list_count;
    EGLint *error;
    yagl_host_handle *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    config = yagl_transport_get_out_yagl_host_handle(t);
    width = yagl_transport_get_out_uint32_t(t);
    height = yagl_transport_get_out_uint32_t(t);
    bpp = yagl_transport_get_out_uint32_t(t);
    pixels = yagl_transport_get_out_va(t);
    yagl_transport_get_out_array(t, sizeof(EGLint), (const void**)&attrib_list, &attrib_list_count);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT8(eglCreateWindowSurfaceOffscreenYAGL, yagl_host_handle, yagl_host_handle, uint32_t, uint32_t, uint32_t, target_ulong, void*, void*, dpy, config, width, height, bpp, pixels, attrib_list, error);
    *retval = yagl_host_eglCreateWindowSurfaceOffscreenYAGL(dpy, config, width, height, bpp, pixels, attrib_list, attrib_list_count, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(yagl_host_handle, *retval);
}

/*
 * eglCreatePbufferSurfaceOffscreenYAGL dispatcher. id = 20
 */
static void yagl_func_eglCreatePbufferSurfaceOffscreenYAGL(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle config;
    uint32_t width;
    uint32_t height;
    uint32_t bpp;
    target_ulong pixels;
    const EGLint *attrib_list;
    int32_t attrib_list_count;
    EGLint *error;
    yagl_host_handle *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    config = yagl_transport_get_out_yagl_host_handle(t);
    width = yagl_transport_get_out_uint32_t(t);
    height = yagl_transport_get_out_uint32_t(t);
    bpp = yagl_transport_get_out_uint32_t(t);
    pixels = yagl_transport_get_out_va(t);
    yagl_transport_get_out_array(t, sizeof(EGLint), (const void**)&attrib_list, &attrib_list_count);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT8(eglCreatePbufferSurfaceOffscreenYAGL, yagl_host_handle, yagl_host_handle, uint32_t, uint32_t, uint32_t, target_ulong, void*, void*, dpy, config, width, height, bpp, pixels, attrib_list, error);
    *retval = yagl_host_eglCreatePbufferSurfaceOffscreenYAGL(dpy, config, width, height, bpp, pixels, attrib_list, attrib_list_count, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(yagl_host_handle, *retval);
}

/*
 * eglCreatePixmapSurfaceOffscreenYAGL dispatcher. id = 21
 */
static void yagl_func_eglCreatePixmapSurfaceOffscreenYAGL(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle config;
    uint32_t width;
    uint32_t height;
    uint32_t bpp;
    target_ulong pixels;
    const EGLint *attrib_list;
    int32_t attrib_list_count;
    EGLint *error;
    yagl_host_handle *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    config = yagl_transport_get_out_yagl_host_handle(t);
    width = yagl_transport_get_out_uint32_t(t);
    height = yagl_transport_get_out_uint32_t(t);
    bpp = yagl_transport_get_out_uint32_t(t);
    pixels = yagl_transport_get_out_va(t);
    yagl_transport_get_out_array(t, sizeof(EGLint), (const void**)&attrib_list, &attrib_list_count);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT8(eglCreatePixmapSurfaceOffscreenYAGL, yagl_host_handle, yagl_host_handle, uint32_t, uint32_t, uint32_t, target_ulong, void*, void*, dpy, config, width, height, bpp, pixels, attrib_list, error);
    *retval = yagl_host_eglCreatePixmapSurfaceOffscreenYAGL(dpy, config, width, height, bpp, pixels, attrib_list, attrib_list_count, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(yagl_host_handle, *retval);
}

/*
 * eglResizeOffscreenSurfaceYAGL dispatcher. id = 22
 */
static void yagl_func_eglResizeOffscreenSurfaceYAGL(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle surface;
    uint32_t width;
    uint32_t height;
    uint32_t bpp;
    target_ulong pixels;
    EGLint *error;
    EGLBoolean *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    surface = yagl_transport_get_out_yagl_host_handle(t);
    width = yagl_transport_get_out_uint32_t(t);
    height = yagl_transport_get_out_uint32_t(t);
    bpp = yagl_transport_get_out_uint32_t(t);
    pixels = yagl_transport_get_out_va(t);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT7(eglResizeOffscreenSurfaceYAGL, yagl_host_handle, yagl_host_handle, uint32_t, uint32_t, uint32_t, target_ulong, void*, dpy, surface, width, height, bpp, pixels, error);
    *retval = yagl_host_eglResizeOffscreenSurfaceYAGL(dpy, surface, width, height, bpp, pixels, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

/*
 * eglCreateWindowSurfaceOnscreenYAGL dispatcher. id = 23
 */
static void yagl_func_eglCreateWindowSurfaceOnscreenYAGL(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle config;
    yagl_winsys_id win;
    const EGLint *attrib_list;
    int32_t attrib_list_count;
    EGLint *error;
    yagl_host_handle *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    config = yagl_transport_get_out_yagl_host_handle(t);
    win = yagl_transport_get_out_yagl_winsys_id(t);
    yagl_transport_get_out_array(t, sizeof(EGLint), (const void**)&attrib_list, &attrib_list_count);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT5(eglCreateWindowSurfaceOnscreenYAGL, yagl_host_handle, yagl_host_handle, yagl_winsys_id, void*, void*, dpy, config, win, attrib_list, error);
    *retval = yagl_host_eglCreateWindowSurfaceOnscreenYAGL(dpy, config, win, attrib_list, attrib_list_count, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(yagl_host_handle, *retval);
}

/*
 * eglCreatePbufferSurfaceOnscreenYAGL dispatcher. id = 24
 */
static void yagl_func_eglCreatePbufferSurfaceOnscreenYAGL(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle config;
    yagl_winsys_id buffer;
    const EGLint *attrib_list;
    int32_t attrib_list_count;
    EGLint *error;
    yagl_host_handle *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    config = yagl_transport_get_out_yagl_host_handle(t);
    buffer = yagl_transport_get_out_yagl_winsys_id(t);
    yagl_transport_get_out_array(t, sizeof(EGLint), (const void**)&attrib_list, &attrib_list_count);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT5(eglCreatePbufferSurfaceOnscreenYAGL, yagl_host_handle, yagl_host_handle, yagl_winsys_id, void*, void*, dpy, config, buffer, attrib_list, error);
    *retval = yagl_host_eglCreatePbufferSurfaceOnscreenYAGL(dpy, config, buffer, attrib_list, attrib_list_count, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(yagl_host_handle, *retval);
}

/*
 * eglCreatePixmapSurfaceOnscreenYAGL dispatcher. id = 25
 */
static void yagl_func_eglCreatePixmapSurfaceOnscreenYAGL(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle config;
    yagl_winsys_id pixmap;
    const EGLint *attrib_list;
    int32_t attrib_list_count;
    EGLint *error;
    yagl_host_handle *retval;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    config = yagl_transport_get_out_yagl_host_handle(t);
    pixmap = yagl_transport_get_out_yagl_winsys_id(t);
    yagl_transport_get_out_array(t, sizeof(EGLint), (const void**)&attrib_list, &attrib_list_count);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT5(eglCreatePixmapSurfaceOnscreenYAGL, yagl_host_handle, yagl_host_handle, yagl_winsys_id, void*, void*, dpy, config, pixmap, attrib_list, error);
    *retval = yagl_host_eglCreatePixmapSurfaceOnscreenYAGL(dpy, config, pixmap, attrib_list, attrib_list_count, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(yagl_host_handle, *retval);
}

/*
 * eglInvalidateOnscreenSurfaceYAGL dispatcher. id = 26
 */
static void yagl_func_eglInvalidateOnscreenSurfaceYAGL(struct yagl_transport *t)
{
    yagl_host_handle dpy;
    yagl_host_handle surface;
    yagl_winsys_id buffer;
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    surface = yagl_transport_get_out_yagl_host_handle(t);
    buffer = yagl_transport_get_out_yagl_winsys_id(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(eglInvalidateOnscreenSurfaceYAGL, yagl_host_handle, yagl_host_handle, yagl_winsys_id, dpy, surface, buffer);
    (void)yagl_host_eglInvalidateOnscreenSurfaceYAGL(dpy, surface, buffer);
    YAGL_LOG_FUNC_EXIT(NULL);
}

/*
 * eglCreateImageYAGL dispatcher. id = 27
 */
static void yagl_func_eglCreateImageYAGL(struct yagl_transport *t)
{
    uint32_t texture;
    yagl_host_handle dpy;
    yagl_winsys_id buffer;
    EGLint *error;
    EGLBoolean *retval;
    texture = yagl_transport_get_out_uint32_t(t);
    dpy = yagl_transport_get_out_yagl_host_handle(t);
    buffer = yagl_transport_get_out_yagl_winsys_id(t);
    yagl_transport_get_in_arg(t, (void**)&error);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT4(eglCreateImageYAGL, uint32_t, yagl_host_handle, yagl_winsys_id, void*, texture, dpy, buffer, error);
    *retval = yagl_host_eglCreateImageYAGL(texture, dpy, buffer, error);
    YAGL_LOG_FUNC_EXIT_SPLIT(EGLBoolean, *retval);
}

const uint32_t yagl_egl_api_num_funcs = 27;

yagl_api_func yagl_egl_api_funcs[] = {
    &yagl_func_eglGetDisplay,
    &yagl_func_eglInitialize,
    &yagl_func_eglTerminate,
    &yagl_func_eglGetConfigs,
    &yagl_func_eglChooseConfig,
    &yagl_func_eglGetConfigAttrib,
    &yagl_func_eglDestroySurface,
    &yagl_func_eglQuerySurface,
    &yagl_func_eglBindAPI,
    &yagl_func_eglWaitClient,
    &yagl_func_eglReleaseThread,
    &yagl_func_eglSurfaceAttrib,
    &yagl_func_eglCreateContext,
    &yagl_func_eglDestroyContext,
    &yagl_func_eglMakeCurrent,
    &yagl_func_eglQueryContext,
    &yagl_func_eglSwapBuffers,
    &yagl_func_eglCopyBuffers,
    &yagl_func_eglCreateWindowSurfaceOffscreenYAGL,
    &yagl_func_eglCreatePbufferSurfaceOffscreenYAGL,
    &yagl_func_eglCreatePixmapSurfaceOffscreenYAGL,
    &yagl_func_eglResizeOffscreenSurfaceYAGL,
    &yagl_func_eglCreateWindowSurfaceOnscreenYAGL,
    &yagl_func_eglCreatePbufferSurfaceOnscreenYAGL,
    &yagl_func_eglCreatePixmapSurfaceOnscreenYAGL,
    &yagl_func_eglInvalidateOnscreenSurfaceYAGL,
    &yagl_func_eglCreateImageYAGL,
};
