/*
 * Generated by gen-yagl-calls.py, do not modify!
 */
#include "yagl_gles_calls.h"
#include "yagl_host_gles_calls.h"
#include "yagl_transport_gl.h"
#include "yagl_thread.h"
#include "yagl_process.h"
#include "yagl_log.h"

/*
 * glDrawArrays dispatcher. id = 1
 */
static bool yagl_func_glDrawArrays(struct yagl_transport *t)
{
    GLenum mode;
    GLint first;
    GLsizei count;
    mode = yagl_transport_get_out_GLenum(t);
    first = yagl_transport_get_out_GLint(t);
    count = yagl_transport_get_out_GLsizei(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glDrawArrays, GLenum, GLint, GLsizei, mode, first, count);
    (void)yagl_host_glDrawArrays(mode, first, count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glDrawElements dispatcher. id = 2
 */
static bool yagl_func_glDrawElements(struct yagl_transport *t)
{
    GLenum mode;
    GLsizei count;
    GLenum type;
    const GLvoid *indices;
    int32_t indices_count;
    mode = yagl_transport_get_out_GLenum(t);
    count = yagl_transport_get_out_GLsizei(t);
    type = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&indices, &indices_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT4(glDrawElements, GLenum, GLsizei, GLenum, void*, mode, count, type, indices);
    (void)yagl_host_glDrawElements(mode, count, type, indices, indices_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glReadPixels dispatcher. id = 3
 */
static bool yagl_func_glReadPixels(struct yagl_transport *t)
{
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid *pixels;
    int32_t pixels_maxcount;
    int32_t *pixels_count;
    x = yagl_transport_get_out_GLint(t);
    y = yagl_transport_get_out_GLint(t);
    width = yagl_transport_get_out_GLsizei(t);
    height = yagl_transport_get_out_GLsizei(t);
    format = yagl_transport_get_out_GLenum(t);
    type = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, 1, (void**)&pixels, &pixels_maxcount, &pixels_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT7(glReadPixels, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, void*, x, y, width, height, format, type, pixels);
    *pixels_count = 0;
    (void)yagl_host_glReadPixels(x, y, width, height, format, type, pixels, pixels_maxcount, pixels_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGenVertexArrays dispatcher. id = 4
 */
static bool yagl_func_glGenVertexArrays(struct yagl_transport *t)
{
    const GLuint *arrays;
    int32_t arrays_count;
    if (!yagl_transport_get_out_array(t, sizeof(GLuint), (const void**)&arrays, &arrays_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT1(glGenVertexArrays, void*, arrays);
    (void)yagl_host_glGenVertexArrays(arrays, arrays_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBindVertexArray dispatcher. id = 5
 */
static bool yagl_func_glBindVertexArray(struct yagl_transport *t)
{
    GLuint array;
    array = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glBindVertexArray, GLuint, array);
    (void)yagl_host_glBindVertexArray(array);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glDisableVertexAttribArray dispatcher. id = 6
 */
static bool yagl_func_glDisableVertexAttribArray(struct yagl_transport *t)
{
    GLuint index;
    index = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glDisableVertexAttribArray, GLuint, index);
    (void)yagl_host_glDisableVertexAttribArray(index);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glEnableVertexAttribArray dispatcher. id = 7
 */
static bool yagl_func_glEnableVertexAttribArray(struct yagl_transport *t)
{
    GLuint index;
    index = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glEnableVertexAttribArray, GLuint, index);
    (void)yagl_host_glEnableVertexAttribArray(index);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexAttribPointerData dispatcher. id = 8
 */
static bool yagl_func_glVertexAttribPointerData(struct yagl_transport *t)
{
    GLuint indx;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLint first;
    const GLvoid *data;
    int32_t data_count;
    indx = yagl_transport_get_out_GLuint(t);
    size = yagl_transport_get_out_GLint(t);
    type = yagl_transport_get_out_GLenum(t);
    normalized = yagl_transport_get_out_GLboolean(t);
    stride = yagl_transport_get_out_GLsizei(t);
    first = yagl_transport_get_out_GLint(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&data, &data_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT7(glVertexAttribPointerData, GLuint, GLint, GLenum, GLboolean, GLsizei, GLint, void*, indx, size, type, normalized, stride, first, data);
    (void)yagl_host_glVertexAttribPointerData(indx, size, type, normalized, stride, first, data, data_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexAttribPointerOffset dispatcher. id = 9
 */
static bool yagl_func_glVertexAttribPointerOffset(struct yagl_transport *t)
{
    GLuint indx;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLsizei offset;
    indx = yagl_transport_get_out_GLuint(t);
    size = yagl_transport_get_out_GLint(t);
    type = yagl_transport_get_out_GLenum(t);
    normalized = yagl_transport_get_out_GLboolean(t);
    stride = yagl_transport_get_out_GLsizei(t);
    offset = yagl_transport_get_out_GLsizei(t);
    YAGL_LOG_FUNC_ENTER_SPLIT6(glVertexAttribPointerOffset, GLuint, GLint, GLenum, GLboolean, GLsizei, GLsizei, indx, size, type, normalized, stride, offset);
    (void)yagl_host_glVertexAttribPointerOffset(indx, size, type, normalized, stride, offset);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexPointerData dispatcher. id = 10
 */
static bool yagl_func_glVertexPointerData(struct yagl_transport *t)
{
    GLint size;
    GLenum type;
    GLsizei stride;
    GLint first;
    const GLvoid *data;
    int32_t data_count;
    size = yagl_transport_get_out_GLint(t);
    type = yagl_transport_get_out_GLenum(t);
    stride = yagl_transport_get_out_GLsizei(t);
    first = yagl_transport_get_out_GLint(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&data, &data_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT5(glVertexPointerData, GLint, GLenum, GLsizei, GLint, void*, size, type, stride, first, data);
    (void)yagl_host_glVertexPointerData(size, type, stride, first, data, data_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexPointerOffset dispatcher. id = 11
 */
static bool yagl_func_glVertexPointerOffset(struct yagl_transport *t)
{
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei offset;
    size = yagl_transport_get_out_GLint(t);
    type = yagl_transport_get_out_GLenum(t);
    stride = yagl_transport_get_out_GLsizei(t);
    offset = yagl_transport_get_out_GLsizei(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glVertexPointerOffset, GLint, GLenum, GLsizei, GLsizei, size, type, stride, offset);
    (void)yagl_host_glVertexPointerOffset(size, type, stride, offset);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glNormalPointerData dispatcher. id = 12
 */
static bool yagl_func_glNormalPointerData(struct yagl_transport *t)
{
    GLenum type;
    GLsizei stride;
    GLint first;
    const GLvoid *data;
    int32_t data_count;
    type = yagl_transport_get_out_GLenum(t);
    stride = yagl_transport_get_out_GLsizei(t);
    first = yagl_transport_get_out_GLint(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&data, &data_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT4(glNormalPointerData, GLenum, GLsizei, GLint, void*, type, stride, first, data);
    (void)yagl_host_glNormalPointerData(type, stride, first, data, data_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glNormalPointerOffset dispatcher. id = 13
 */
static bool yagl_func_glNormalPointerOffset(struct yagl_transport *t)
{
    GLenum type;
    GLsizei stride;
    GLsizei offset;
    type = yagl_transport_get_out_GLenum(t);
    stride = yagl_transport_get_out_GLsizei(t);
    offset = yagl_transport_get_out_GLsizei(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glNormalPointerOffset, GLenum, GLsizei, GLsizei, type, stride, offset);
    (void)yagl_host_glNormalPointerOffset(type, stride, offset);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glColorPointerData dispatcher. id = 14
 */
static bool yagl_func_glColorPointerData(struct yagl_transport *t)
{
    GLint size;
    GLenum type;
    GLsizei stride;
    GLint first;
    const GLvoid *data;
    int32_t data_count;
    size = yagl_transport_get_out_GLint(t);
    type = yagl_transport_get_out_GLenum(t);
    stride = yagl_transport_get_out_GLsizei(t);
    first = yagl_transport_get_out_GLint(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&data, &data_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT5(glColorPointerData, GLint, GLenum, GLsizei, GLint, void*, size, type, stride, first, data);
    (void)yagl_host_glColorPointerData(size, type, stride, first, data, data_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glColorPointerOffset dispatcher. id = 15
 */
static bool yagl_func_glColorPointerOffset(struct yagl_transport *t)
{
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei offset;
    size = yagl_transport_get_out_GLint(t);
    type = yagl_transport_get_out_GLenum(t);
    stride = yagl_transport_get_out_GLsizei(t);
    offset = yagl_transport_get_out_GLsizei(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glColorPointerOffset, GLint, GLenum, GLsizei, GLsizei, size, type, stride, offset);
    (void)yagl_host_glColorPointerOffset(size, type, stride, offset);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexCoordPointerData dispatcher. id = 16
 */
static bool yagl_func_glTexCoordPointerData(struct yagl_transport *t)
{
    GLint tex_id;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLint first;
    const GLvoid *data;
    int32_t data_count;
    tex_id = yagl_transport_get_out_GLint(t);
    size = yagl_transport_get_out_GLint(t);
    type = yagl_transport_get_out_GLenum(t);
    stride = yagl_transport_get_out_GLsizei(t);
    first = yagl_transport_get_out_GLint(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&data, &data_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT6(glTexCoordPointerData, GLint, GLint, GLenum, GLsizei, GLint, void*, tex_id, size, type, stride, first, data);
    (void)yagl_host_glTexCoordPointerData(tex_id, size, type, stride, first, data, data_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexCoordPointerOffset dispatcher. id = 17
 */
static bool yagl_func_glTexCoordPointerOffset(struct yagl_transport *t)
{
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei offset;
    size = yagl_transport_get_out_GLint(t);
    type = yagl_transport_get_out_GLenum(t);
    stride = yagl_transport_get_out_GLsizei(t);
    offset = yagl_transport_get_out_GLsizei(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glTexCoordPointerOffset, GLint, GLenum, GLsizei, GLsizei, size, type, stride, offset);
    (void)yagl_host_glTexCoordPointerOffset(size, type, stride, offset);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glDisableClientState dispatcher. id = 18
 */
static bool yagl_func_glDisableClientState(struct yagl_transport *t)
{
    GLenum array;
    array = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glDisableClientState, GLenum, array);
    (void)yagl_host_glDisableClientState(array);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glEnableClientState dispatcher. id = 19
 */
static bool yagl_func_glEnableClientState(struct yagl_transport *t)
{
    GLenum array;
    array = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glEnableClientState, GLenum, array);
    (void)yagl_host_glEnableClientState(array);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGenBuffers dispatcher. id = 20
 */
static bool yagl_func_glGenBuffers(struct yagl_transport *t)
{
    const GLuint *buffers;
    int32_t buffers_count;
    if (!yagl_transport_get_out_array(t, sizeof(GLuint), (const void**)&buffers, &buffers_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT1(glGenBuffers, void*, buffers);
    (void)yagl_host_glGenBuffers(buffers, buffers_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBindBuffer dispatcher. id = 21
 */
static bool yagl_func_glBindBuffer(struct yagl_transport *t)
{
    GLenum target;
    GLuint buffer;
    target = yagl_transport_get_out_GLenum(t);
    buffer = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glBindBuffer, GLenum, GLuint, target, buffer);
    (void)yagl_host_glBindBuffer(target, buffer);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBufferData dispatcher. id = 22
 */
static bool yagl_func_glBufferData(struct yagl_transport *t)
{
    GLenum target;
    const GLvoid *data;
    int32_t data_count;
    GLenum usage;
    target = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&data, &data_count)) {
        return false;
    }
    usage = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glBufferData, GLenum, void*, GLenum, target, data, usage);
    (void)yagl_host_glBufferData(target, data, data_count, usage);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBufferSubData dispatcher. id = 23
 */
static bool yagl_func_glBufferSubData(struct yagl_transport *t)
{
    GLenum target;
    GLsizei offset;
    const GLvoid *data;
    int32_t data_count;
    target = yagl_transport_get_out_GLenum(t);
    offset = yagl_transport_get_out_GLsizei(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&data, &data_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glBufferSubData, GLenum, GLsizei, void*, target, offset, data);
    (void)yagl_host_glBufferSubData(target, offset, data, data_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGenTextures dispatcher. id = 24
 */
static bool yagl_func_glGenTextures(struct yagl_transport *t)
{
    const GLuint *textures;
    int32_t textures_count;
    if (!yagl_transport_get_out_array(t, sizeof(GLuint), (const void**)&textures, &textures_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT1(glGenTextures, void*, textures);
    (void)yagl_host_glGenTextures(textures, textures_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBindTexture dispatcher. id = 25
 */
static bool yagl_func_glBindTexture(struct yagl_transport *t)
{
    GLenum target;
    GLuint texture;
    target = yagl_transport_get_out_GLenum(t);
    texture = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glBindTexture, GLenum, GLuint, target, texture);
    (void)yagl_host_glBindTexture(target, texture);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glActiveTexture dispatcher. id = 26
 */
static bool yagl_func_glActiveTexture(struct yagl_transport *t)
{
    GLenum texture;
    texture = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glActiveTexture, GLenum, texture);
    (void)yagl_host_glActiveTexture(texture);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glCompressedTexImage2D dispatcher. id = 27
 */
static bool yagl_func_glCompressedTexImage2D(struct yagl_transport *t)
{
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    const GLvoid *data;
    int32_t data_count;
    target = yagl_transport_get_out_GLenum(t);
    level = yagl_transport_get_out_GLint(t);
    internalformat = yagl_transport_get_out_GLenum(t);
    width = yagl_transport_get_out_GLsizei(t);
    height = yagl_transport_get_out_GLsizei(t);
    border = yagl_transport_get_out_GLint(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&data, &data_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT7(glCompressedTexImage2D, GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, void*, target, level, internalformat, width, height, border, data);
    (void)yagl_host_glCompressedTexImage2D(target, level, internalformat, width, height, border, data, data_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glCompressedTexSubImage2D dispatcher. id = 28
 */
static bool yagl_func_glCompressedTexSubImage2D(struct yagl_transport *t)
{
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    const GLvoid *data;
    int32_t data_count;
    target = yagl_transport_get_out_GLenum(t);
    level = yagl_transport_get_out_GLint(t);
    xoffset = yagl_transport_get_out_GLint(t);
    yoffset = yagl_transport_get_out_GLint(t);
    width = yagl_transport_get_out_GLsizei(t);
    height = yagl_transport_get_out_GLsizei(t);
    format = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&data, &data_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT8(glCompressedTexSubImage2D, GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, void*, target, level, xoffset, yoffset, width, height, format, data);
    (void)yagl_host_glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data, data_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glCopyTexImage2D dispatcher. id = 29
 */
static bool yagl_func_glCopyTexImage2D(struct yagl_transport *t)
{
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
    target = yagl_transport_get_out_GLenum(t);
    level = yagl_transport_get_out_GLint(t);
    internalformat = yagl_transport_get_out_GLenum(t);
    x = yagl_transport_get_out_GLint(t);
    y = yagl_transport_get_out_GLint(t);
    width = yagl_transport_get_out_GLsizei(t);
    height = yagl_transport_get_out_GLsizei(t);
    border = yagl_transport_get_out_GLint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT8(glCopyTexImage2D, GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint, target, level, internalformat, x, y, width, height, border);
    (void)yagl_host_glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glCopyTexSubImage2D dispatcher. id = 30
 */
static bool yagl_func_glCopyTexSubImage2D(struct yagl_transport *t)
{
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    target = yagl_transport_get_out_GLenum(t);
    level = yagl_transport_get_out_GLint(t);
    xoffset = yagl_transport_get_out_GLint(t);
    yoffset = yagl_transport_get_out_GLint(t);
    x = yagl_transport_get_out_GLint(t);
    y = yagl_transport_get_out_GLint(t);
    width = yagl_transport_get_out_GLsizei(t);
    height = yagl_transport_get_out_GLsizei(t);
    YAGL_LOG_FUNC_ENTER_SPLIT8(glCopyTexSubImage2D, GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, target, level, xoffset, yoffset, x, y, width, height);
    (void)yagl_host_glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetTexParameterfv dispatcher. id = 31
 */
static bool yagl_func_glGetTexParameterfv(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    GLfloat *param;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    yagl_transport_get_in_arg(t, (void**)&param);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetTexParameterfv, GLenum, GLenum, void*, target, pname, param);
    (void)yagl_host_glGetTexParameterfv(target, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetTexParameteriv dispatcher. id = 32
 */
static bool yagl_func_glGetTexParameteriv(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    GLint *param;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    yagl_transport_get_in_arg(t, (void**)&param);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetTexParameteriv, GLenum, GLenum, void*, target, pname, param);
    (void)yagl_host_glGetTexParameteriv(target, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexImage2D dispatcher. id = 33
 */
static bool yagl_func_glTexImage2D(struct yagl_transport *t)
{
    GLenum target;
    GLint level;
    GLint internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLenum format;
    GLenum type;
    const GLvoid *pixels;
    int32_t pixels_count;
    target = yagl_transport_get_out_GLenum(t);
    level = yagl_transport_get_out_GLint(t);
    internalformat = yagl_transport_get_out_GLint(t);
    width = yagl_transport_get_out_GLsizei(t);
    height = yagl_transport_get_out_GLsizei(t);
    border = yagl_transport_get_out_GLint(t);
    format = yagl_transport_get_out_GLenum(t);
    type = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&pixels, &pixels_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT9(glTexImage2D, GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, void*, target, level, internalformat, width, height, border, format, type, pixels);
    (void)yagl_host_glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels, pixels_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexParameterf dispatcher. id = 34
 */
static bool yagl_func_glTexParameterf(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    GLfloat param;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    param = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glTexParameterf, GLenum, GLenum, GLfloat, target, pname, param);
    (void)yagl_host_glTexParameterf(target, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexParameterfv dispatcher. id = 35
 */
static bool yagl_func_glTexParameterfv(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    const GLfloat *params;
    int32_t params_count;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&params, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glTexParameterfv, GLenum, GLenum, void*, target, pname, params);
    (void)yagl_host_glTexParameterfv(target, pname, params, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexParameteri dispatcher. id = 36
 */
static bool yagl_func_glTexParameteri(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    GLint param;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    param = yagl_transport_get_out_GLint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glTexParameteri, GLenum, GLenum, GLint, target, pname, param);
    (void)yagl_host_glTexParameteri(target, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexParameteriv dispatcher. id = 37
 */
static bool yagl_func_glTexParameteriv(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    const GLint *params;
    int32_t params_count;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLint), (const void**)&params, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glTexParameteriv, GLenum, GLenum, void*, target, pname, params);
    (void)yagl_host_glTexParameteriv(target, pname, params, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexSubImage2D dispatcher. id = 38
 */
static bool yagl_func_glTexSubImage2D(struct yagl_transport *t)
{
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    const GLvoid *pixels;
    int32_t pixels_count;
    target = yagl_transport_get_out_GLenum(t);
    level = yagl_transport_get_out_GLint(t);
    xoffset = yagl_transport_get_out_GLint(t);
    yoffset = yagl_transport_get_out_GLint(t);
    width = yagl_transport_get_out_GLsizei(t);
    height = yagl_transport_get_out_GLsizei(t);
    format = yagl_transport_get_out_GLenum(t);
    type = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&pixels, &pixels_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT9(glTexSubImage2D, GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, void*, target, level, xoffset, yoffset, width, height, format, type, pixels);
    (void)yagl_host_glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels, pixels_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glClientActiveTexture dispatcher. id = 39
 */
static bool yagl_func_glClientActiveTexture(struct yagl_transport *t)
{
    GLenum texture;
    texture = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glClientActiveTexture, GLenum, texture);
    (void)yagl_host_glClientActiveTexture(texture);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexEnvi dispatcher. id = 40
 */
static bool yagl_func_glTexEnvi(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    GLint param;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    param = yagl_transport_get_out_GLint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glTexEnvi, GLenum, GLenum, GLint, target, pname, param);
    (void)yagl_host_glTexEnvi(target, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexEnvf dispatcher. id = 41
 */
static bool yagl_func_glTexEnvf(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    GLfloat param;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    param = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glTexEnvf, GLenum, GLenum, GLfloat, target, pname, param);
    (void)yagl_host_glTexEnvf(target, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glMultiTexCoord4f dispatcher. id = 42
 */
static bool yagl_func_glMultiTexCoord4f(struct yagl_transport *t)
{
    GLenum target;
    GLfloat s;
    GLfloat tt;
    GLfloat r;
    GLfloat q;
    target = yagl_transport_get_out_GLenum(t);
    s = yagl_transport_get_out_GLfloat(t);
    tt = yagl_transport_get_out_GLfloat(t);
    r = yagl_transport_get_out_GLfloat(t);
    q = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT5(glMultiTexCoord4f, GLenum, GLfloat, GLfloat, GLfloat, GLfloat, target, s, tt, r, q);
    (void)yagl_host_glMultiTexCoord4f(target, s, tt, r, q);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexEnviv dispatcher. id = 43
 */
static bool yagl_func_glTexEnviv(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    const GLint *params;
    int32_t params_count;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLint), (const void**)&params, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glTexEnviv, GLenum, GLenum, void*, target, pname, params);
    (void)yagl_host_glTexEnviv(target, pname, params, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTexEnvfv dispatcher. id = 44
 */
static bool yagl_func_glTexEnvfv(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    const GLfloat *params;
    int32_t params_count;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&params, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glTexEnvfv, GLenum, GLenum, void*, target, pname, params);
    (void)yagl_host_glTexEnvfv(target, pname, params, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetTexEnviv dispatcher. id = 45
 */
static bool yagl_func_glGetTexEnviv(struct yagl_transport *t)
{
    GLenum env;
    GLenum pname;
    GLint *params;
    int32_t params_maxcount;
    int32_t *params_count;
    env = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLint), (void**)&params, &params_maxcount, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetTexEnviv, GLenum, GLenum, void*, env, pname, params);
    *params_count = 0;
    (void)yagl_host_glGetTexEnviv(env, pname, params, params_maxcount, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetTexEnvfv dispatcher. id = 46
 */
static bool yagl_func_glGetTexEnvfv(struct yagl_transport *t)
{
    GLenum env;
    GLenum pname;
    GLfloat *params;
    int32_t params_maxcount;
    int32_t *params_count;
    env = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLfloat), (void**)&params, &params_maxcount, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetTexEnvfv, GLenum, GLenum, void*, env, pname, params);
    *params_count = 0;
    (void)yagl_host_glGetTexEnvfv(env, pname, params, params_maxcount, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGenFramebuffers dispatcher. id = 47
 */
static bool yagl_func_glGenFramebuffers(struct yagl_transport *t)
{
    const GLuint *framebuffers;
    int32_t framebuffers_count;
    if (!yagl_transport_get_out_array(t, sizeof(GLuint), (const void**)&framebuffers, &framebuffers_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT1(glGenFramebuffers, void*, framebuffers);
    (void)yagl_host_glGenFramebuffers(framebuffers, framebuffers_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBindFramebuffer dispatcher. id = 48
 */
static bool yagl_func_glBindFramebuffer(struct yagl_transport *t)
{
    GLenum target;
    GLuint framebuffer;
    target = yagl_transport_get_out_GLenum(t);
    framebuffer = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glBindFramebuffer, GLenum, GLuint, target, framebuffer);
    (void)yagl_host_glBindFramebuffer(target, framebuffer);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glFramebufferTexture2D dispatcher. id = 49
 */
static bool yagl_func_glFramebufferTexture2D(struct yagl_transport *t)
{
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
    target = yagl_transport_get_out_GLenum(t);
    attachment = yagl_transport_get_out_GLenum(t);
    textarget = yagl_transport_get_out_GLenum(t);
    texture = yagl_transport_get_out_GLuint(t);
    level = yagl_transport_get_out_GLint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT5(glFramebufferTexture2D, GLenum, GLenum, GLenum, GLuint, GLint, target, attachment, textarget, texture, level);
    (void)yagl_host_glFramebufferTexture2D(target, attachment, textarget, texture, level);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glFramebufferRenderbuffer dispatcher. id = 50
 */
static bool yagl_func_glFramebufferRenderbuffer(struct yagl_transport *t)
{
    GLenum target;
    GLenum attachment;
    GLenum renderbuffertarget;
    GLuint renderbuffer;
    target = yagl_transport_get_out_GLenum(t);
    attachment = yagl_transport_get_out_GLenum(t);
    renderbuffertarget = yagl_transport_get_out_GLenum(t);
    renderbuffer = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glFramebufferRenderbuffer, GLenum, GLenum, GLenum, GLuint, target, attachment, renderbuffertarget, renderbuffer);
    (void)yagl_host_glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBlitFramebuffer dispatcher. id = 51
 */
static bool yagl_func_glBlitFramebuffer(struct yagl_transport *t)
{
    GLint srcX0;
    GLint srcY0;
    GLint srcX1;
    GLint srcY1;
    GLint dstX0;
    GLint dstY0;
    GLint dstX1;
    GLint dstY1;
    GLbitfield mask;
    GLenum filter;
    srcX0 = yagl_transport_get_out_GLint(t);
    srcY0 = yagl_transport_get_out_GLint(t);
    srcX1 = yagl_transport_get_out_GLint(t);
    srcY1 = yagl_transport_get_out_GLint(t);
    dstX0 = yagl_transport_get_out_GLint(t);
    dstY0 = yagl_transport_get_out_GLint(t);
    dstX1 = yagl_transport_get_out_GLint(t);
    dstY1 = yagl_transport_get_out_GLint(t);
    mask = yagl_transport_get_out_GLbitfield(t);
    filter = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT10(glBlitFramebuffer, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    (void)yagl_host_glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGenRenderbuffers dispatcher. id = 52
 */
static bool yagl_func_glGenRenderbuffers(struct yagl_transport *t)
{
    const GLuint *renderbuffers;
    int32_t renderbuffers_count;
    if (!yagl_transport_get_out_array(t, sizeof(GLuint), (const void**)&renderbuffers, &renderbuffers_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT1(glGenRenderbuffers, void*, renderbuffers);
    (void)yagl_host_glGenRenderbuffers(renderbuffers, renderbuffers_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBindRenderbuffer dispatcher. id = 53
 */
static bool yagl_func_glBindRenderbuffer(struct yagl_transport *t)
{
    GLenum target;
    GLuint renderbuffer;
    target = yagl_transport_get_out_GLenum(t);
    renderbuffer = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glBindRenderbuffer, GLenum, GLuint, target, renderbuffer);
    (void)yagl_host_glBindRenderbuffer(target, renderbuffer);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glRenderbufferStorage dispatcher. id = 54
 */
static bool yagl_func_glRenderbufferStorage(struct yagl_transport *t)
{
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    target = yagl_transport_get_out_GLenum(t);
    internalformat = yagl_transport_get_out_GLenum(t);
    width = yagl_transport_get_out_GLsizei(t);
    height = yagl_transport_get_out_GLsizei(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glRenderbufferStorage, GLenum, GLenum, GLsizei, GLsizei, target, internalformat, width, height);
    (void)yagl_host_glRenderbufferStorage(target, internalformat, width, height);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetRenderbufferParameteriv dispatcher. id = 55
 */
static bool yagl_func_glGetRenderbufferParameteriv(struct yagl_transport *t)
{
    GLenum target;
    GLenum pname;
    GLint *param;
    target = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    yagl_transport_get_in_arg(t, (void**)&param);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetRenderbufferParameteriv, GLenum, GLenum, void*, target, pname, param);
    (void)yagl_host_glGetRenderbufferParameteriv(target, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glCreateProgram dispatcher. id = 56
 */
static bool yagl_func_glCreateProgram(struct yagl_transport *t)
{
    GLuint program;
    program = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glCreateProgram, GLuint, program);
    (void)yagl_host_glCreateProgram(program);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glCreateShader dispatcher. id = 57
 */
static bool yagl_func_glCreateShader(struct yagl_transport *t)
{
    GLuint shader;
    GLenum type;
    shader = yagl_transport_get_out_GLuint(t);
    type = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glCreateShader, GLuint, GLenum, shader, type);
    (void)yagl_host_glCreateShader(shader, type);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glShaderSource dispatcher. id = 58
 */
static bool yagl_func_glShaderSource(struct yagl_transport *t)
{
    GLuint shader;
    const GLchar *string;
    int32_t string_count;
    shader = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLchar), (const void**)&string, &string_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glShaderSource, GLuint, void*, shader, string);
    (void)yagl_host_glShaderSource(shader, string, string_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glAttachShader dispatcher. id = 59
 */
static bool yagl_func_glAttachShader(struct yagl_transport *t)
{
    GLuint program;
    GLuint shader;
    program = yagl_transport_get_out_GLuint(t);
    shader = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glAttachShader, GLuint, GLuint, program, shader);
    (void)yagl_host_glAttachShader(program, shader);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glDetachShader dispatcher. id = 60
 */
static bool yagl_func_glDetachShader(struct yagl_transport *t)
{
    GLuint program;
    GLuint shader;
    program = yagl_transport_get_out_GLuint(t);
    shader = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glDetachShader, GLuint, GLuint, program, shader);
    (void)yagl_host_glDetachShader(program, shader);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glCompileShader dispatcher. id = 61
 */
static bool yagl_func_glCompileShader(struct yagl_transport *t)
{
    GLuint shader;
    shader = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glCompileShader, GLuint, shader);
    (void)yagl_host_glCompileShader(shader);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBindAttribLocation dispatcher. id = 62
 */
static bool yagl_func_glBindAttribLocation(struct yagl_transport *t)
{
    GLuint program;
    GLuint index;
    const GLchar *name;
    int32_t name_count;
    program = yagl_transport_get_out_GLuint(t);
    index = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLchar), (const void**)&name, &name_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glBindAttribLocation, GLuint, GLuint, void*, program, index, name);
    (void)yagl_host_glBindAttribLocation(program, index, name, name_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetActiveAttrib dispatcher. id = 63
 */
static bool yagl_func_glGetActiveAttrib(struct yagl_transport *t)
{
    GLuint program;
    GLuint index;
    GLint *size;
    GLenum *type;
    GLchar *name;
    int32_t name_maxcount;
    int32_t *name_count;
    GLboolean *retval;
    program = yagl_transport_get_out_GLuint(t);
    index = yagl_transport_get_out_GLuint(t);
    yagl_transport_get_in_arg(t, (void**)&size);
    yagl_transport_get_in_arg(t, (void**)&type);
    if (!yagl_transport_get_in_array(t, sizeof(GLchar), (void**)&name, &name_maxcount, &name_count)) {
        return false;
    }
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT5(glGetActiveAttrib, GLuint, GLuint, void*, void*, void*, program, index, size, type, name);
    *name_count = 0;
    *retval = yagl_host_glGetActiveAttrib(program, index, size, type, name, name_maxcount, name_count);
    YAGL_LOG_FUNC_EXIT_SPLIT(GLboolean, *retval);

    return true;
}

/*
 * glGetActiveUniform dispatcher. id = 64
 */
static bool yagl_func_glGetActiveUniform(struct yagl_transport *t)
{
    GLuint program;
    GLuint index;
    GLint *size;
    GLenum *type;
    GLchar *name;
    int32_t name_maxcount;
    int32_t *name_count;
    GLboolean *retval;
    program = yagl_transport_get_out_GLuint(t);
    index = yagl_transport_get_out_GLuint(t);
    yagl_transport_get_in_arg(t, (void**)&size);
    yagl_transport_get_in_arg(t, (void**)&type);
    if (!yagl_transport_get_in_array(t, sizeof(GLchar), (void**)&name, &name_maxcount, &name_count)) {
        return false;
    }
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT5(glGetActiveUniform, GLuint, GLuint, void*, void*, void*, program, index, size, type, name);
    *name_count = 0;
    *retval = yagl_host_glGetActiveUniform(program, index, size, type, name, name_maxcount, name_count);
    YAGL_LOG_FUNC_EXIT_SPLIT(GLboolean, *retval);

    return true;
}

/*
 * glGetAttribLocation dispatcher. id = 65
 */
static bool yagl_func_glGetAttribLocation(struct yagl_transport *t)
{
    GLuint program;
    const GLchar *name;
    int32_t name_count;
    int *retval;
    program = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLchar), (const void**)&name, &name_count)) {
        return false;
    }
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glGetAttribLocation, GLuint, void*, program, name);
    *retval = yagl_host_glGetAttribLocation(program, name, name_count);
    YAGL_LOG_FUNC_EXIT_SPLIT(int, *retval);

    return true;
}

/*
 * glGetProgramiv dispatcher. id = 66
 */
static bool yagl_func_glGetProgramiv(struct yagl_transport *t)
{
    GLuint program;
    GLenum pname;
    GLint *param;
    program = yagl_transport_get_out_GLuint(t);
    pname = yagl_transport_get_out_GLenum(t);
    yagl_transport_get_in_arg(t, (void**)&param);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetProgramiv, GLuint, GLenum, void*, program, pname, param);
    (void)yagl_host_glGetProgramiv(program, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetProgramInfoLog dispatcher. id = 67
 */
static bool yagl_func_glGetProgramInfoLog(struct yagl_transport *t)
{
    GLuint program;
    GLchar *infolog;
    int32_t infolog_maxcount;
    int32_t *infolog_count;
    GLboolean *retval;
    program = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLchar), (void**)&infolog, &infolog_maxcount, &infolog_count)) {
        return false;
    }
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glGetProgramInfoLog, GLuint, void*, program, infolog);
    *infolog_count = 0;
    *retval = yagl_host_glGetProgramInfoLog(program, infolog, infolog_maxcount, infolog_count);
    YAGL_LOG_FUNC_EXIT_SPLIT(GLboolean, *retval);

    return true;
}

/*
 * glGetShaderiv dispatcher. id = 68
 */
static bool yagl_func_glGetShaderiv(struct yagl_transport *t)
{
    GLuint shader;
    GLenum pname;
    GLint *param;
    shader = yagl_transport_get_out_GLuint(t);
    pname = yagl_transport_get_out_GLenum(t);
    yagl_transport_get_in_arg(t, (void**)&param);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetShaderiv, GLuint, GLenum, void*, shader, pname, param);
    (void)yagl_host_glGetShaderiv(shader, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetShaderInfoLog dispatcher. id = 69
 */
static bool yagl_func_glGetShaderInfoLog(struct yagl_transport *t)
{
    GLuint shader;
    GLchar *infolog;
    int32_t infolog_maxcount;
    int32_t *infolog_count;
    GLboolean *retval;
    shader = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLchar), (void**)&infolog, &infolog_maxcount, &infolog_count)) {
        return false;
    }
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glGetShaderInfoLog, GLuint, void*, shader, infolog);
    *infolog_count = 0;
    *retval = yagl_host_glGetShaderInfoLog(shader, infolog, infolog_maxcount, infolog_count);
    YAGL_LOG_FUNC_EXIT_SPLIT(GLboolean, *retval);

    return true;
}

/*
 * glGetUniformfv dispatcher. id = 70
 */
static bool yagl_func_glGetUniformfv(struct yagl_transport *t)
{
    GLboolean tl;
    GLuint program;
    uint32_t location;
    GLfloat *params;
    int32_t params_maxcount;
    int32_t *params_count;
    tl = yagl_transport_get_out_GLboolean(t);
    program = yagl_transport_get_out_GLuint(t);
    location = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLfloat), (void**)&params, &params_maxcount, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT4(glGetUniformfv, GLboolean, GLuint, uint32_t, void*, tl, program, location, params);
    *params_count = 0;
    (void)yagl_host_glGetUniformfv(tl, program, location, params, params_maxcount, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetUniformiv dispatcher. id = 71
 */
static bool yagl_func_glGetUniformiv(struct yagl_transport *t)
{
    GLboolean tl;
    GLuint program;
    uint32_t location;
    GLint *params;
    int32_t params_maxcount;
    int32_t *params_count;
    tl = yagl_transport_get_out_GLboolean(t);
    program = yagl_transport_get_out_GLuint(t);
    location = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLint), (void**)&params, &params_maxcount, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT4(glGetUniformiv, GLboolean, GLuint, uint32_t, void*, tl, program, location, params);
    *params_count = 0;
    (void)yagl_host_glGetUniformiv(tl, program, location, params, params_maxcount, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetUniformLocation dispatcher. id = 72
 */
static bool yagl_func_glGetUniformLocation(struct yagl_transport *t)
{
    GLuint program;
    const GLchar *name;
    int32_t name_count;
    int *retval;
    program = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLchar), (const void**)&name, &name_count)) {
        return false;
    }
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glGetUniformLocation, GLuint, void*, program, name);
    *retval = yagl_host_glGetUniformLocation(program, name, name_count);
    YAGL_LOG_FUNC_EXIT_SPLIT(int, *retval);

    return true;
}

/*
 * glGetVertexAttribfv dispatcher. id = 73
 */
static bool yagl_func_glGetVertexAttribfv(struct yagl_transport *t)
{
    GLuint index;
    GLenum pname;
    GLfloat *params;
    int32_t params_maxcount;
    int32_t *params_count;
    index = yagl_transport_get_out_GLuint(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLfloat), (void**)&params, &params_maxcount, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetVertexAttribfv, GLuint, GLenum, void*, index, pname, params);
    *params_count = 0;
    (void)yagl_host_glGetVertexAttribfv(index, pname, params, params_maxcount, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetVertexAttribiv dispatcher. id = 74
 */
static bool yagl_func_glGetVertexAttribiv(struct yagl_transport *t)
{
    GLuint index;
    GLenum pname;
    GLint *params;
    int32_t params_maxcount;
    int32_t *params_count;
    index = yagl_transport_get_out_GLuint(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLint), (void**)&params, &params_maxcount, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetVertexAttribiv, GLuint, GLenum, void*, index, pname, params);
    *params_count = 0;
    (void)yagl_host_glGetVertexAttribiv(index, pname, params, params_maxcount, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glLinkProgram dispatcher. id = 75
 */
static bool yagl_func_glLinkProgram(struct yagl_transport *t)
{
    GLuint program;
    program = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glLinkProgram, GLuint, program);
    (void)yagl_host_glLinkProgram(program);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform1f dispatcher. id = 76
 */
static bool yagl_func_glUniform1f(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLfloat x;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    x = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glUniform1f, GLboolean, uint32_t, GLfloat, tl, location, x);
    (void)yagl_host_glUniform1f(tl, location, x);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform1fv dispatcher. id = 77
 */
static bool yagl_func_glUniform1fv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    const GLfloat *v;
    int32_t v_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&v, &v_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glUniform1fv, GLboolean, uint32_t, void*, tl, location, v);
    (void)yagl_host_glUniform1fv(tl, location, v, v_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform1i dispatcher. id = 78
 */
static bool yagl_func_glUniform1i(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLint x;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    x = yagl_transport_get_out_GLint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glUniform1i, GLboolean, uint32_t, GLint, tl, location, x);
    (void)yagl_host_glUniform1i(tl, location, x);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform1iv dispatcher. id = 79
 */
static bool yagl_func_glUniform1iv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    const GLint *v;
    int32_t v_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLint), (const void**)&v, &v_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glUniform1iv, GLboolean, uint32_t, void*, tl, location, v);
    (void)yagl_host_glUniform1iv(tl, location, v, v_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform2f dispatcher. id = 80
 */
static bool yagl_func_glUniform2f(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLfloat x;
    GLfloat y;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    x = yagl_transport_get_out_GLfloat(t);
    y = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glUniform2f, GLboolean, uint32_t, GLfloat, GLfloat, tl, location, x, y);
    (void)yagl_host_glUniform2f(tl, location, x, y);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform2fv dispatcher. id = 81
 */
static bool yagl_func_glUniform2fv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    const GLfloat *v;
    int32_t v_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&v, &v_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glUniform2fv, GLboolean, uint32_t, void*, tl, location, v);
    (void)yagl_host_glUniform2fv(tl, location, v, v_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform2i dispatcher. id = 82
 */
static bool yagl_func_glUniform2i(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLint x;
    GLint y;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    x = yagl_transport_get_out_GLint(t);
    y = yagl_transport_get_out_GLint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glUniform2i, GLboolean, uint32_t, GLint, GLint, tl, location, x, y);
    (void)yagl_host_glUniform2i(tl, location, x, y);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform2iv dispatcher. id = 83
 */
static bool yagl_func_glUniform2iv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    const GLint *v;
    int32_t v_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLint), (const void**)&v, &v_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glUniform2iv, GLboolean, uint32_t, void*, tl, location, v);
    (void)yagl_host_glUniform2iv(tl, location, v, v_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform3f dispatcher. id = 84
 */
static bool yagl_func_glUniform3f(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    x = yagl_transport_get_out_GLfloat(t);
    y = yagl_transport_get_out_GLfloat(t);
    z = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT5(glUniform3f, GLboolean, uint32_t, GLfloat, GLfloat, GLfloat, tl, location, x, y, z);
    (void)yagl_host_glUniform3f(tl, location, x, y, z);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform3fv dispatcher. id = 85
 */
static bool yagl_func_glUniform3fv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    const GLfloat *v;
    int32_t v_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&v, &v_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glUniform3fv, GLboolean, uint32_t, void*, tl, location, v);
    (void)yagl_host_glUniform3fv(tl, location, v, v_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform3i dispatcher. id = 86
 */
static bool yagl_func_glUniform3i(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLint x;
    GLint y;
    GLint z;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    x = yagl_transport_get_out_GLint(t);
    y = yagl_transport_get_out_GLint(t);
    z = yagl_transport_get_out_GLint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT5(glUniform3i, GLboolean, uint32_t, GLint, GLint, GLint, tl, location, x, y, z);
    (void)yagl_host_glUniform3i(tl, location, x, y, z);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform3iv dispatcher. id = 87
 */
static bool yagl_func_glUniform3iv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    const GLint *v;
    int32_t v_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLint), (const void**)&v, &v_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glUniform3iv, GLboolean, uint32_t, void*, tl, location, v);
    (void)yagl_host_glUniform3iv(tl, location, v, v_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform4f dispatcher. id = 88
 */
static bool yagl_func_glUniform4f(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    x = yagl_transport_get_out_GLfloat(t);
    y = yagl_transport_get_out_GLfloat(t);
    z = yagl_transport_get_out_GLfloat(t);
    w = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT6(glUniform4f, GLboolean, uint32_t, GLfloat, GLfloat, GLfloat, GLfloat, tl, location, x, y, z, w);
    (void)yagl_host_glUniform4f(tl, location, x, y, z, w);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform4fv dispatcher. id = 89
 */
static bool yagl_func_glUniform4fv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    const GLfloat *v;
    int32_t v_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&v, &v_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glUniform4fv, GLboolean, uint32_t, void*, tl, location, v);
    (void)yagl_host_glUniform4fv(tl, location, v, v_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform4i dispatcher. id = 90
 */
static bool yagl_func_glUniform4i(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    x = yagl_transport_get_out_GLint(t);
    y = yagl_transport_get_out_GLint(t);
    z = yagl_transport_get_out_GLint(t);
    w = yagl_transport_get_out_GLint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT6(glUniform4i, GLboolean, uint32_t, GLint, GLint, GLint, GLint, tl, location, x, y, z, w);
    (void)yagl_host_glUniform4i(tl, location, x, y, z, w);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniform4iv dispatcher. id = 91
 */
static bool yagl_func_glUniform4iv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    const GLint *v;
    int32_t v_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLint), (const void**)&v, &v_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glUniform4iv, GLboolean, uint32_t, void*, tl, location, v);
    (void)yagl_host_glUniform4iv(tl, location, v, v_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniformMatrix2fv dispatcher. id = 92
 */
static bool yagl_func_glUniformMatrix2fv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLboolean transpose;
    const GLfloat *value;
    int32_t value_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    transpose = yagl_transport_get_out_GLboolean(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&value, &value_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT4(glUniformMatrix2fv, GLboolean, uint32_t, GLboolean, void*, tl, location, transpose, value);
    (void)yagl_host_glUniformMatrix2fv(tl, location, transpose, value, value_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniformMatrix3fv dispatcher. id = 93
 */
static bool yagl_func_glUniformMatrix3fv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLboolean transpose;
    const GLfloat *value;
    int32_t value_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    transpose = yagl_transport_get_out_GLboolean(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&value, &value_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT4(glUniformMatrix3fv, GLboolean, uint32_t, GLboolean, void*, tl, location, transpose, value);
    (void)yagl_host_glUniformMatrix3fv(tl, location, transpose, value, value_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUniformMatrix4fv dispatcher. id = 94
 */
static bool yagl_func_glUniformMatrix4fv(struct yagl_transport *t)
{
    GLboolean tl;
    uint32_t location;
    GLboolean transpose;
    const GLfloat *value;
    int32_t value_count;
    tl = yagl_transport_get_out_GLboolean(t);
    location = yagl_transport_get_out_uint32_t(t);
    transpose = yagl_transport_get_out_GLboolean(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&value, &value_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT4(glUniformMatrix4fv, GLboolean, uint32_t, GLboolean, void*, tl, location, transpose, value);
    (void)yagl_host_glUniformMatrix4fv(tl, location, transpose, value, value_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUseProgram dispatcher. id = 95
 */
static bool yagl_func_glUseProgram(struct yagl_transport *t)
{
    GLuint program;
    program = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glUseProgram, GLuint, program);
    (void)yagl_host_glUseProgram(program);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glValidateProgram dispatcher. id = 96
 */
static bool yagl_func_glValidateProgram(struct yagl_transport *t)
{
    GLuint program;
    program = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glValidateProgram, GLuint, program);
    (void)yagl_host_glValidateProgram(program);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexAttrib1f dispatcher. id = 97
 */
static bool yagl_func_glVertexAttrib1f(struct yagl_transport *t)
{
    GLuint indx;
    GLfloat x;
    indx = yagl_transport_get_out_GLuint(t);
    x = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glVertexAttrib1f, GLuint, GLfloat, indx, x);
    (void)yagl_host_glVertexAttrib1f(indx, x);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexAttrib1fv dispatcher. id = 98
 */
static bool yagl_func_glVertexAttrib1fv(struct yagl_transport *t)
{
    GLuint indx;
    const GLfloat *values;
    int32_t values_count;
    indx = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&values, &values_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glVertexAttrib1fv, GLuint, void*, indx, values);
    (void)yagl_host_glVertexAttrib1fv(indx, values, values_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexAttrib2f dispatcher. id = 99
 */
static bool yagl_func_glVertexAttrib2f(struct yagl_transport *t)
{
    GLuint indx;
    GLfloat x;
    GLfloat y;
    indx = yagl_transport_get_out_GLuint(t);
    x = yagl_transport_get_out_GLfloat(t);
    y = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glVertexAttrib2f, GLuint, GLfloat, GLfloat, indx, x, y);
    (void)yagl_host_glVertexAttrib2f(indx, x, y);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexAttrib2fv dispatcher. id = 100
 */
static bool yagl_func_glVertexAttrib2fv(struct yagl_transport *t)
{
    GLuint indx;
    const GLfloat *values;
    int32_t values_count;
    indx = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&values, &values_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glVertexAttrib2fv, GLuint, void*, indx, values);
    (void)yagl_host_glVertexAttrib2fv(indx, values, values_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexAttrib3f dispatcher. id = 101
 */
static bool yagl_func_glVertexAttrib3f(struct yagl_transport *t)
{
    GLuint indx;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    indx = yagl_transport_get_out_GLuint(t);
    x = yagl_transport_get_out_GLfloat(t);
    y = yagl_transport_get_out_GLfloat(t);
    z = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glVertexAttrib3f, GLuint, GLfloat, GLfloat, GLfloat, indx, x, y, z);
    (void)yagl_host_glVertexAttrib3f(indx, x, y, z);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexAttrib3fv dispatcher. id = 102
 */
static bool yagl_func_glVertexAttrib3fv(struct yagl_transport *t)
{
    GLuint indx;
    const GLfloat *values;
    int32_t values_count;
    indx = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&values, &values_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glVertexAttrib3fv, GLuint, void*, indx, values);
    (void)yagl_host_glVertexAttrib3fv(indx, values, values_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexAttrib4f dispatcher. id = 103
 */
static bool yagl_func_glVertexAttrib4f(struct yagl_transport *t)
{
    GLuint indx;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
    indx = yagl_transport_get_out_GLuint(t);
    x = yagl_transport_get_out_GLfloat(t);
    y = yagl_transport_get_out_GLfloat(t);
    z = yagl_transport_get_out_GLfloat(t);
    w = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT5(glVertexAttrib4f, GLuint, GLfloat, GLfloat, GLfloat, GLfloat, indx, x, y, z, w);
    (void)yagl_host_glVertexAttrib4f(indx, x, y, z, w);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glVertexAttrib4fv dispatcher. id = 104
 */
static bool yagl_func_glVertexAttrib4fv(struct yagl_transport *t)
{
    GLuint indx;
    const GLfloat *values;
    int32_t values_count;
    indx = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&values, &values_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glVertexAttrib4fv, GLuint, void*, indx, values);
    (void)yagl_host_glVertexAttrib4fv(indx, values, values_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetIntegerv dispatcher. id = 105
 */
static bool yagl_func_glGetIntegerv(struct yagl_transport *t)
{
    GLenum pname;
    GLint *params;
    int32_t params_maxcount;
    int32_t *params_count;
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLint), (void**)&params, &params_maxcount, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glGetIntegerv, GLenum, void*, pname, params);
    *params_count = 0;
    (void)yagl_host_glGetIntegerv(pname, params, params_maxcount, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetFloatv dispatcher. id = 106
 */
static bool yagl_func_glGetFloatv(struct yagl_transport *t)
{
    GLenum pname;
    GLfloat *params;
    int32_t params_maxcount;
    int32_t *params_count;
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLfloat), (void**)&params, &params_maxcount, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glGetFloatv, GLenum, void*, pname, params);
    *params_count = 0;
    (void)yagl_host_glGetFloatv(pname, params, params_maxcount, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetString dispatcher. id = 107
 */
static bool yagl_func_glGetString(struct yagl_transport *t)
{
    GLenum name;
    GLchar *str;
    int32_t str_maxcount;
    int32_t *str_count;
    name = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLchar), (void**)&str, &str_maxcount, &str_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glGetString, GLenum, void*, name, str);
    *str_count = 0;
    (void)yagl_host_glGetString(name, str, str_maxcount, str_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glIsEnabled dispatcher. id = 108
 */
static bool yagl_func_glIsEnabled(struct yagl_transport *t)
{
    GLenum cap;
    GLboolean *retval;
    cap = yagl_transport_get_out_GLenum(t);
    yagl_transport_get_in_arg(t, (void**)&retval);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glIsEnabled, GLenum, cap);
    *retval = yagl_host_glIsEnabled(cap);
    YAGL_LOG_FUNC_EXIT_SPLIT(GLboolean, *retval);

    return true;
}

/*
 * glDeleteObjects dispatcher. id = 109
 */
static bool yagl_func_glDeleteObjects(struct yagl_transport *t)
{
    const GLuint *objects;
    int32_t objects_count;
    if (!yagl_transport_get_out_array(t, sizeof(GLuint), (const void**)&objects, &objects_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT1(glDeleteObjects, void*, objects);
    (void)yagl_host_glDeleteObjects(objects, objects_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBlendEquation dispatcher. id = 110
 */
static bool yagl_func_glBlendEquation(struct yagl_transport *t)
{
    GLenum mode;
    mode = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glBlendEquation, GLenum, mode);
    (void)yagl_host_glBlendEquation(mode);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBlendEquationSeparate dispatcher. id = 111
 */
static bool yagl_func_glBlendEquationSeparate(struct yagl_transport *t)
{
    GLenum modeRGB;
    GLenum modeAlpha;
    modeRGB = yagl_transport_get_out_GLenum(t);
    modeAlpha = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glBlendEquationSeparate, GLenum, GLenum, modeRGB, modeAlpha);
    (void)yagl_host_glBlendEquationSeparate(modeRGB, modeAlpha);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBlendFunc dispatcher. id = 112
 */
static bool yagl_func_glBlendFunc(struct yagl_transport *t)
{
    GLenum sfactor;
    GLenum dfactor;
    sfactor = yagl_transport_get_out_GLenum(t);
    dfactor = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glBlendFunc, GLenum, GLenum, sfactor, dfactor);
    (void)yagl_host_glBlendFunc(sfactor, dfactor);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBlendFuncSeparate dispatcher. id = 113
 */
static bool yagl_func_glBlendFuncSeparate(struct yagl_transport *t)
{
    GLenum srcRGB;
    GLenum dstRGB;
    GLenum srcAlpha;
    GLenum dstAlpha;
    srcRGB = yagl_transport_get_out_GLenum(t);
    dstRGB = yagl_transport_get_out_GLenum(t);
    srcAlpha = yagl_transport_get_out_GLenum(t);
    dstAlpha = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glBlendFuncSeparate, GLenum, GLenum, GLenum, GLenum, srcRGB, dstRGB, srcAlpha, dstAlpha);
    (void)yagl_host_glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glBlendColor dispatcher. id = 114
 */
static bool yagl_func_glBlendColor(struct yagl_transport *t)
{
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;
    red = yagl_transport_get_out_GLclampf(t);
    green = yagl_transport_get_out_GLclampf(t);
    blue = yagl_transport_get_out_GLclampf(t);
    alpha = yagl_transport_get_out_GLclampf(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glBlendColor, GLclampf, GLclampf, GLclampf, GLclampf, red, green, blue, alpha);
    (void)yagl_host_glBlendColor(red, green, blue, alpha);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glClear dispatcher. id = 115
 */
static bool yagl_func_glClear(struct yagl_transport *t)
{
    GLbitfield mask;
    mask = yagl_transport_get_out_GLbitfield(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glClear, GLbitfield, mask);
    (void)yagl_host_glClear(mask);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glClearColor dispatcher. id = 116
 */
static bool yagl_func_glClearColor(struct yagl_transport *t)
{
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;
    red = yagl_transport_get_out_GLclampf(t);
    green = yagl_transport_get_out_GLclampf(t);
    blue = yagl_transport_get_out_GLclampf(t);
    alpha = yagl_transport_get_out_GLclampf(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glClearColor, GLclampf, GLclampf, GLclampf, GLclampf, red, green, blue, alpha);
    (void)yagl_host_glClearColor(red, green, blue, alpha);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glClearDepthf dispatcher. id = 117
 */
static bool yagl_func_glClearDepthf(struct yagl_transport *t)
{
    GLclampf depth;
    depth = yagl_transport_get_out_GLclampf(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glClearDepthf, GLclampf, depth);
    (void)yagl_host_glClearDepthf(depth);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glClearStencil dispatcher. id = 118
 */
static bool yagl_func_glClearStencil(struct yagl_transport *t)
{
    GLint s;
    s = yagl_transport_get_out_GLint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glClearStencil, GLint, s);
    (void)yagl_host_glClearStencil(s);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glColorMask dispatcher. id = 119
 */
static bool yagl_func_glColorMask(struct yagl_transport *t)
{
    GLboolean red;
    GLboolean green;
    GLboolean blue;
    GLboolean alpha;
    red = yagl_transport_get_out_GLboolean(t);
    green = yagl_transport_get_out_GLboolean(t);
    blue = yagl_transport_get_out_GLboolean(t);
    alpha = yagl_transport_get_out_GLboolean(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glColorMask, GLboolean, GLboolean, GLboolean, GLboolean, red, green, blue, alpha);
    (void)yagl_host_glColorMask(red, green, blue, alpha);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glCullFace dispatcher. id = 120
 */
static bool yagl_func_glCullFace(struct yagl_transport *t)
{
    GLenum mode;
    mode = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glCullFace, GLenum, mode);
    (void)yagl_host_glCullFace(mode);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glDepthFunc dispatcher. id = 121
 */
static bool yagl_func_glDepthFunc(struct yagl_transport *t)
{
    GLenum func;
    func = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glDepthFunc, GLenum, func);
    (void)yagl_host_glDepthFunc(func);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glDepthMask dispatcher. id = 122
 */
static bool yagl_func_glDepthMask(struct yagl_transport *t)
{
    GLboolean flag;
    flag = yagl_transport_get_out_GLboolean(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glDepthMask, GLboolean, flag);
    (void)yagl_host_glDepthMask(flag);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glDepthRangef dispatcher. id = 123
 */
static bool yagl_func_glDepthRangef(struct yagl_transport *t)
{
    GLclampf zNear;
    GLclampf zFar;
    zNear = yagl_transport_get_out_GLclampf(t);
    zFar = yagl_transport_get_out_GLclampf(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glDepthRangef, GLclampf, GLclampf, zNear, zFar);
    (void)yagl_host_glDepthRangef(zNear, zFar);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glEnable dispatcher. id = 124
 */
static bool yagl_func_glEnable(struct yagl_transport *t)
{
    GLenum cap;
    cap = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glEnable, GLenum, cap);
    (void)yagl_host_glEnable(cap);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glDisable dispatcher. id = 125
 */
static bool yagl_func_glDisable(struct yagl_transport *t)
{
    GLenum cap;
    cap = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glDisable, GLenum, cap);
    (void)yagl_host_glDisable(cap);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glFlush dispatcher. id = 126
 */
static bool yagl_func_glFlush(struct yagl_transport *t)
{
    YAGL_LOG_FUNC_ENTER_SPLIT0(glFlush);
    (void)yagl_host_glFlush();
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glFrontFace dispatcher. id = 127
 */
static bool yagl_func_glFrontFace(struct yagl_transport *t)
{
    GLenum mode;
    mode = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glFrontFace, GLenum, mode);
    (void)yagl_host_glFrontFace(mode);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGenerateMipmap dispatcher. id = 128
 */
static bool yagl_func_glGenerateMipmap(struct yagl_transport *t)
{
    GLenum target;
    target = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glGenerateMipmap, GLenum, target);
    (void)yagl_host_glGenerateMipmap(target);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glHint dispatcher. id = 129
 */
static bool yagl_func_glHint(struct yagl_transport *t)
{
    GLenum target;
    GLenum mode;
    target = yagl_transport_get_out_GLenum(t);
    mode = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glHint, GLenum, GLenum, target, mode);
    (void)yagl_host_glHint(target, mode);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glLineWidth dispatcher. id = 130
 */
static bool yagl_func_glLineWidth(struct yagl_transport *t)
{
    GLfloat width;
    width = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glLineWidth, GLfloat, width);
    (void)yagl_host_glLineWidth(width);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glPixelStorei dispatcher. id = 131
 */
static bool yagl_func_glPixelStorei(struct yagl_transport *t)
{
    GLenum pname;
    GLint param;
    pname = yagl_transport_get_out_GLenum(t);
    param = yagl_transport_get_out_GLint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glPixelStorei, GLenum, GLint, pname, param);
    (void)yagl_host_glPixelStorei(pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glPolygonOffset dispatcher. id = 132
 */
static bool yagl_func_glPolygonOffset(struct yagl_transport *t)
{
    GLfloat factor;
    GLfloat units;
    factor = yagl_transport_get_out_GLfloat(t);
    units = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glPolygonOffset, GLfloat, GLfloat, factor, units);
    (void)yagl_host_glPolygonOffset(factor, units);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glScissor dispatcher. id = 133
 */
static bool yagl_func_glScissor(struct yagl_transport *t)
{
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    x = yagl_transport_get_out_GLint(t);
    y = yagl_transport_get_out_GLint(t);
    width = yagl_transport_get_out_GLsizei(t);
    height = yagl_transport_get_out_GLsizei(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glScissor, GLint, GLint, GLsizei, GLsizei, x, y, width, height);
    (void)yagl_host_glScissor(x, y, width, height);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glStencilFunc dispatcher. id = 134
 */
static bool yagl_func_glStencilFunc(struct yagl_transport *t)
{
    GLenum func;
    GLint ref;
    GLuint mask;
    func = yagl_transport_get_out_GLenum(t);
    ref = yagl_transport_get_out_GLint(t);
    mask = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glStencilFunc, GLenum, GLint, GLuint, func, ref, mask);
    (void)yagl_host_glStencilFunc(func, ref, mask);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glStencilMask dispatcher. id = 135
 */
static bool yagl_func_glStencilMask(struct yagl_transport *t)
{
    GLuint mask;
    mask = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glStencilMask, GLuint, mask);
    (void)yagl_host_glStencilMask(mask);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glStencilOp dispatcher. id = 136
 */
static bool yagl_func_glStencilOp(struct yagl_transport *t)
{
    GLenum fail;
    GLenum zfail;
    GLenum zpass;
    fail = yagl_transport_get_out_GLenum(t);
    zfail = yagl_transport_get_out_GLenum(t);
    zpass = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glStencilOp, GLenum, GLenum, GLenum, fail, zfail, zpass);
    (void)yagl_host_glStencilOp(fail, zfail, zpass);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glSampleCoverage dispatcher. id = 137
 */
static bool yagl_func_glSampleCoverage(struct yagl_transport *t)
{
    GLclampf value;
    GLboolean invert;
    value = yagl_transport_get_out_GLclampf(t);
    invert = yagl_transport_get_out_GLboolean(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glSampleCoverage, GLclampf, GLboolean, value, invert);
    (void)yagl_host_glSampleCoverage(value, invert);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glViewport dispatcher. id = 138
 */
static bool yagl_func_glViewport(struct yagl_transport *t)
{
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    x = yagl_transport_get_out_GLint(t);
    y = yagl_transport_get_out_GLint(t);
    width = yagl_transport_get_out_GLsizei(t);
    height = yagl_transport_get_out_GLsizei(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glViewport, GLint, GLint, GLsizei, GLsizei, x, y, width, height);
    (void)yagl_host_glViewport(x, y, width, height);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glStencilFuncSeparate dispatcher. id = 139
 */
static bool yagl_func_glStencilFuncSeparate(struct yagl_transport *t)
{
    GLenum face;
    GLenum func;
    GLint ref;
    GLuint mask;
    face = yagl_transport_get_out_GLenum(t);
    func = yagl_transport_get_out_GLenum(t);
    ref = yagl_transport_get_out_GLint(t);
    mask = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glStencilFuncSeparate, GLenum, GLenum, GLint, GLuint, face, func, ref, mask);
    (void)yagl_host_glStencilFuncSeparate(face, func, ref, mask);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glStencilMaskSeparate dispatcher. id = 140
 */
static bool yagl_func_glStencilMaskSeparate(struct yagl_transport *t)
{
    GLenum face;
    GLuint mask;
    face = yagl_transport_get_out_GLenum(t);
    mask = yagl_transport_get_out_GLuint(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glStencilMaskSeparate, GLenum, GLuint, face, mask);
    (void)yagl_host_glStencilMaskSeparate(face, mask);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glStencilOpSeparate dispatcher. id = 141
 */
static bool yagl_func_glStencilOpSeparate(struct yagl_transport *t)
{
    GLenum face;
    GLenum fail;
    GLenum zfail;
    GLenum zpass;
    face = yagl_transport_get_out_GLenum(t);
    fail = yagl_transport_get_out_GLenum(t);
    zfail = yagl_transport_get_out_GLenum(t);
    zpass = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glStencilOpSeparate, GLenum, GLenum, GLenum, GLenum, face, fail, zfail, zpass);
    (void)yagl_host_glStencilOpSeparate(face, fail, zfail, zpass);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glPointSize dispatcher. id = 142
 */
static bool yagl_func_glPointSize(struct yagl_transport *t)
{
    GLfloat size;
    size = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glPointSize, GLfloat, size);
    (void)yagl_host_glPointSize(size);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glAlphaFunc dispatcher. id = 143
 */
static bool yagl_func_glAlphaFunc(struct yagl_transport *t)
{
    GLenum func;
    GLclampf ref;
    func = yagl_transport_get_out_GLenum(t);
    ref = yagl_transport_get_out_GLclampf(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glAlphaFunc, GLenum, GLclampf, func, ref);
    (void)yagl_host_glAlphaFunc(func, ref);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glMatrixMode dispatcher. id = 144
 */
static bool yagl_func_glMatrixMode(struct yagl_transport *t)
{
    GLenum mode;
    mode = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glMatrixMode, GLenum, mode);
    (void)yagl_host_glMatrixMode(mode);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glLoadIdentity dispatcher. id = 145
 */
static bool yagl_func_glLoadIdentity(struct yagl_transport *t)
{
    YAGL_LOG_FUNC_ENTER_SPLIT0(glLoadIdentity);
    (void)yagl_host_glLoadIdentity();
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glPopMatrix dispatcher. id = 146
 */
static bool yagl_func_glPopMatrix(struct yagl_transport *t)
{
    YAGL_LOG_FUNC_ENTER_SPLIT0(glPopMatrix);
    (void)yagl_host_glPopMatrix();
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glPushMatrix dispatcher. id = 147
 */
static bool yagl_func_glPushMatrix(struct yagl_transport *t)
{
    YAGL_LOG_FUNC_ENTER_SPLIT0(glPushMatrix);
    (void)yagl_host_glPushMatrix();
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glRotatef dispatcher. id = 148
 */
static bool yagl_func_glRotatef(struct yagl_transport *t)
{
    GLfloat angle;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    angle = yagl_transport_get_out_GLfloat(t);
    x = yagl_transport_get_out_GLfloat(t);
    y = yagl_transport_get_out_GLfloat(t);
    z = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glRotatef, GLfloat, GLfloat, GLfloat, GLfloat, angle, x, y, z);
    (void)yagl_host_glRotatef(angle, x, y, z);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glTranslatef dispatcher. id = 149
 */
static bool yagl_func_glTranslatef(struct yagl_transport *t)
{
    GLfloat x;
    GLfloat y;
    GLfloat z;
    x = yagl_transport_get_out_GLfloat(t);
    y = yagl_transport_get_out_GLfloat(t);
    z = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glTranslatef, GLfloat, GLfloat, GLfloat, x, y, z);
    (void)yagl_host_glTranslatef(x, y, z);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glScalef dispatcher. id = 150
 */
static bool yagl_func_glScalef(struct yagl_transport *t)
{
    GLfloat x;
    GLfloat y;
    GLfloat z;
    x = yagl_transport_get_out_GLfloat(t);
    y = yagl_transport_get_out_GLfloat(t);
    z = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glScalef, GLfloat, GLfloat, GLfloat, x, y, z);
    (void)yagl_host_glScalef(x, y, z);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glOrthof dispatcher. id = 151
 */
static bool yagl_func_glOrthof(struct yagl_transport *t)
{
    GLfloat left;
    GLfloat right;
    GLfloat bottom;
    GLfloat top;
    GLfloat zNear;
    GLfloat zFar;
    left = yagl_transport_get_out_GLfloat(t);
    right = yagl_transport_get_out_GLfloat(t);
    bottom = yagl_transport_get_out_GLfloat(t);
    top = yagl_transport_get_out_GLfloat(t);
    zNear = yagl_transport_get_out_GLfloat(t);
    zFar = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT6(glOrthof, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, left, right, bottom, top, zNear, zFar);
    (void)yagl_host_glOrthof(left, right, bottom, top, zNear, zFar);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glColor4f dispatcher. id = 152
 */
static bool yagl_func_glColor4f(struct yagl_transport *t)
{
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
    red = yagl_transport_get_out_GLfloat(t);
    green = yagl_transport_get_out_GLfloat(t);
    blue = yagl_transport_get_out_GLfloat(t);
    alpha = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glColor4f, GLfloat, GLfloat, GLfloat, GLfloat, red, green, blue, alpha);
    (void)yagl_host_glColor4f(red, green, blue, alpha);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glColor4ub dispatcher. id = 153
 */
static bool yagl_func_glColor4ub(struct yagl_transport *t)
{
    GLubyte red;
    GLubyte green;
    GLubyte blue;
    GLubyte alpha;
    red = yagl_transport_get_out_GLubyte(t);
    green = yagl_transport_get_out_GLubyte(t);
    blue = yagl_transport_get_out_GLubyte(t);
    alpha = yagl_transport_get_out_GLubyte(t);
    YAGL_LOG_FUNC_ENTER_SPLIT4(glColor4ub, GLubyte, GLubyte, GLubyte, GLubyte, red, green, blue, alpha);
    (void)yagl_host_glColor4ub(red, green, blue, alpha);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glNormal3f dispatcher. id = 154
 */
static bool yagl_func_glNormal3f(struct yagl_transport *t)
{
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    nx = yagl_transport_get_out_GLfloat(t);
    ny = yagl_transport_get_out_GLfloat(t);
    nz = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glNormal3f, GLfloat, GLfloat, GLfloat, nx, ny, nz);
    (void)yagl_host_glNormal3f(nx, ny, nz);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glPointParameterf dispatcher. id = 155
 */
static bool yagl_func_glPointParameterf(struct yagl_transport *t)
{
    GLenum pname;
    GLfloat param;
    pname = yagl_transport_get_out_GLenum(t);
    param = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glPointParameterf, GLenum, GLfloat, pname, param);
    (void)yagl_host_glPointParameterf(pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glPointParameterfv dispatcher. id = 156
 */
static bool yagl_func_glPointParameterfv(struct yagl_transport *t)
{
    GLenum pname;
    const GLfloat *params;
    int32_t params_count;
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&params, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glPointParameterfv, GLenum, void*, pname, params);
    (void)yagl_host_glPointParameterfv(pname, params, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glFogf dispatcher. id = 157
 */
static bool yagl_func_glFogf(struct yagl_transport *t)
{
    GLenum pname;
    GLfloat param;
    pname = yagl_transport_get_out_GLenum(t);
    param = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glFogf, GLenum, GLfloat, pname, param);
    (void)yagl_host_glFogf(pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glFogfv dispatcher. id = 158
 */
static bool yagl_func_glFogfv(struct yagl_transport *t)
{
    GLenum pname;
    const GLfloat *params;
    int32_t params_count;
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&params, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glFogfv, GLenum, void*, pname, params);
    (void)yagl_host_glFogfv(pname, params, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glFrustumf dispatcher. id = 159
 */
static bool yagl_func_glFrustumf(struct yagl_transport *t)
{
    GLfloat left;
    GLfloat right;
    GLfloat bottom;
    GLfloat top;
    GLfloat zNear;
    GLfloat zFar;
    left = yagl_transport_get_out_GLfloat(t);
    right = yagl_transport_get_out_GLfloat(t);
    bottom = yagl_transport_get_out_GLfloat(t);
    top = yagl_transport_get_out_GLfloat(t);
    zNear = yagl_transport_get_out_GLfloat(t);
    zFar = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT6(glFrustumf, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, left, right, bottom, top, zNear, zFar);
    (void)yagl_host_glFrustumf(left, right, bottom, top, zNear, zFar);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glLightf dispatcher. id = 160
 */
static bool yagl_func_glLightf(struct yagl_transport *t)
{
    GLenum light;
    GLenum pname;
    GLfloat param;
    light = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    param = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glLightf, GLenum, GLenum, GLfloat, light, pname, param);
    (void)yagl_host_glLightf(light, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glLightfv dispatcher. id = 161
 */
static bool yagl_func_glLightfv(struct yagl_transport *t)
{
    GLenum light;
    GLenum pname;
    const GLfloat *params;
    int32_t params_count;
    light = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&params, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glLightfv, GLenum, GLenum, void*, light, pname, params);
    (void)yagl_host_glLightfv(light, pname, params, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetLightfv dispatcher. id = 162
 */
static bool yagl_func_glGetLightfv(struct yagl_transport *t)
{
    GLenum light;
    GLenum pname;
    GLfloat *params;
    int32_t params_maxcount;
    int32_t *params_count;
    light = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLfloat), (void**)&params, &params_maxcount, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetLightfv, GLenum, GLenum, void*, light, pname, params);
    *params_count = 0;
    (void)yagl_host_glGetLightfv(light, pname, params, params_maxcount, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glLightModelf dispatcher. id = 163
 */
static bool yagl_func_glLightModelf(struct yagl_transport *t)
{
    GLenum pname;
    GLfloat param;
    pname = yagl_transport_get_out_GLenum(t);
    param = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT2(glLightModelf, GLenum, GLfloat, pname, param);
    (void)yagl_host_glLightModelf(pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glLightModelfv dispatcher. id = 164
 */
static bool yagl_func_glLightModelfv(struct yagl_transport *t)
{
    GLenum pname;
    const GLfloat *params;
    int32_t params_count;
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&params, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glLightModelfv, GLenum, void*, pname, params);
    (void)yagl_host_glLightModelfv(pname, params, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glMaterialf dispatcher. id = 165
 */
static bool yagl_func_glMaterialf(struct yagl_transport *t)
{
    GLenum face;
    GLenum pname;
    GLfloat param;
    face = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    param = yagl_transport_get_out_GLfloat(t);
    YAGL_LOG_FUNC_ENTER_SPLIT3(glMaterialf, GLenum, GLenum, GLfloat, face, pname, param);
    (void)yagl_host_glMaterialf(face, pname, param);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glMaterialfv dispatcher. id = 166
 */
static bool yagl_func_glMaterialfv(struct yagl_transport *t)
{
    GLenum face;
    GLenum pname;
    const GLfloat *params;
    int32_t params_count;
    face = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&params, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glMaterialfv, GLenum, GLenum, void*, face, pname, params);
    (void)yagl_host_glMaterialfv(face, pname, params, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetMaterialfv dispatcher. id = 167
 */
static bool yagl_func_glGetMaterialfv(struct yagl_transport *t)
{
    GLenum face;
    GLenum pname;
    GLfloat *params;
    int32_t params_maxcount;
    int32_t *params_count;
    face = yagl_transport_get_out_GLenum(t);
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLfloat), (void**)&params, &params_maxcount, &params_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGetMaterialfv, GLenum, GLenum, void*, face, pname, params);
    *params_count = 0;
    (void)yagl_host_glGetMaterialfv(face, pname, params, params_maxcount, params_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glShadeModel dispatcher. id = 168
 */
static bool yagl_func_glShadeModel(struct yagl_transport *t)
{
    GLenum mode;
    mode = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glShadeModel, GLenum, mode);
    (void)yagl_host_glShadeModel(mode);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glLogicOp dispatcher. id = 169
 */
static bool yagl_func_glLogicOp(struct yagl_transport *t)
{
    GLenum opcode;
    opcode = yagl_transport_get_out_GLenum(t);
    YAGL_LOG_FUNC_ENTER_SPLIT1(glLogicOp, GLenum, opcode);
    (void)yagl_host_glLogicOp(opcode);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glMultMatrixf dispatcher. id = 170
 */
static bool yagl_func_glMultMatrixf(struct yagl_transport *t)
{
    const GLfloat *m;
    int32_t m_count;
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&m, &m_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT1(glMultMatrixf, void*, m);
    (void)yagl_host_glMultMatrixf(m, m_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glLoadMatrixf dispatcher. id = 171
 */
static bool yagl_func_glLoadMatrixf(struct yagl_transport *t)
{
    const GLfloat *m;
    int32_t m_count;
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&m, &m_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT1(glLoadMatrixf, void*, m);
    (void)yagl_host_glLoadMatrixf(m, m_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glClipPlanef dispatcher. id = 172
 */
static bool yagl_func_glClipPlanef(struct yagl_transport *t)
{
    GLenum plane;
    const GLfloat *equation;
    int32_t equation_count;
    plane = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLfloat), (const void**)&equation, &equation_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glClipPlanef, GLenum, void*, plane, equation);
    (void)yagl_host_glClipPlanef(plane, equation, equation_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGetClipPlanef dispatcher. id = 173
 */
static bool yagl_func_glGetClipPlanef(struct yagl_transport *t)
{
    GLenum pname;
    GLfloat *eqn;
    int32_t eqn_maxcount;
    int32_t *eqn_count;
    pname = yagl_transport_get_out_GLenum(t);
    if (!yagl_transport_get_in_array(t, sizeof(GLfloat), (void**)&eqn, &eqn_maxcount, &eqn_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT2(glGetClipPlanef, GLenum, void*, pname, eqn);
    *eqn_count = 0;
    (void)yagl_host_glGetClipPlanef(pname, eqn, eqn_maxcount, eqn_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glUpdateOffscreenImageYAGL dispatcher. id = 174
 */
static bool yagl_func_glUpdateOffscreenImageYAGL(struct yagl_transport *t)
{
    GLuint texture;
    uint32_t width;
    uint32_t height;
    uint32_t bpp;
    const void *pixels;
    int32_t pixels_count;
    texture = yagl_transport_get_out_GLuint(t);
    width = yagl_transport_get_out_uint32_t(t);
    height = yagl_transport_get_out_uint32_t(t);
    bpp = yagl_transport_get_out_uint32_t(t);
    if (!yagl_transport_get_out_array(t, 1, (const void**)&pixels, &pixels_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT5(glUpdateOffscreenImageYAGL, GLuint, uint32_t, uint32_t, uint32_t, void*, texture, width, height, bpp, pixels);
    (void)yagl_host_glUpdateOffscreenImageYAGL(texture, width, height, bpp, pixels, pixels_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glGenUniformLocationYAGL dispatcher. id = 175
 */
static bool yagl_func_glGenUniformLocationYAGL(struct yagl_transport *t)
{
    uint32_t location;
    GLuint program;
    const GLchar *name;
    int32_t name_count;
    location = yagl_transport_get_out_uint32_t(t);
    program = yagl_transport_get_out_GLuint(t);
    if (!yagl_transport_get_out_array(t, sizeof(GLchar), (const void**)&name, &name_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT3(glGenUniformLocationYAGL, uint32_t, GLuint, void*, location, program, name);
    (void)yagl_host_glGenUniformLocationYAGL(location, program, name, name_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

/*
 * glDeleteUniformLocationsYAGL dispatcher. id = 176
 */
static bool yagl_func_glDeleteUniformLocationsYAGL(struct yagl_transport *t)
{
    const uint32_t *locations;
    int32_t locations_count;
    if (!yagl_transport_get_out_array(t, sizeof(uint32_t), (const void**)&locations, &locations_count)) {
        return false;
    }
    YAGL_LOG_FUNC_ENTER_SPLIT1(glDeleteUniformLocationsYAGL, void*, locations);
    (void)yagl_host_glDeleteUniformLocationsYAGL(locations, locations_count);
    YAGL_LOG_FUNC_EXIT(NULL);

    return true;
}

const uint32_t yagl_gles_api_num_funcs = 176;

yagl_api_func yagl_gles_api_funcs[] = {
    &yagl_func_glDrawArrays,
    &yagl_func_glDrawElements,
    &yagl_func_glReadPixels,
    &yagl_func_glGenVertexArrays,
    &yagl_func_glBindVertexArray,
    &yagl_func_glDisableVertexAttribArray,
    &yagl_func_glEnableVertexAttribArray,
    &yagl_func_glVertexAttribPointerData,
    &yagl_func_glVertexAttribPointerOffset,
    &yagl_func_glVertexPointerData,
    &yagl_func_glVertexPointerOffset,
    &yagl_func_glNormalPointerData,
    &yagl_func_glNormalPointerOffset,
    &yagl_func_glColorPointerData,
    &yagl_func_glColorPointerOffset,
    &yagl_func_glTexCoordPointerData,
    &yagl_func_glTexCoordPointerOffset,
    &yagl_func_glDisableClientState,
    &yagl_func_glEnableClientState,
    &yagl_func_glGenBuffers,
    &yagl_func_glBindBuffer,
    &yagl_func_glBufferData,
    &yagl_func_glBufferSubData,
    &yagl_func_glGenTextures,
    &yagl_func_glBindTexture,
    &yagl_func_glActiveTexture,
    &yagl_func_glCompressedTexImage2D,
    &yagl_func_glCompressedTexSubImage2D,
    &yagl_func_glCopyTexImage2D,
    &yagl_func_glCopyTexSubImage2D,
    &yagl_func_glGetTexParameterfv,
    &yagl_func_glGetTexParameteriv,
    &yagl_func_glTexImage2D,
    &yagl_func_glTexParameterf,
    &yagl_func_glTexParameterfv,
    &yagl_func_glTexParameteri,
    &yagl_func_glTexParameteriv,
    &yagl_func_glTexSubImage2D,
    &yagl_func_glClientActiveTexture,
    &yagl_func_glTexEnvi,
    &yagl_func_glTexEnvf,
    &yagl_func_glMultiTexCoord4f,
    &yagl_func_glTexEnviv,
    &yagl_func_glTexEnvfv,
    &yagl_func_glGetTexEnviv,
    &yagl_func_glGetTexEnvfv,
    &yagl_func_glGenFramebuffers,
    &yagl_func_glBindFramebuffer,
    &yagl_func_glFramebufferTexture2D,
    &yagl_func_glFramebufferRenderbuffer,
    &yagl_func_glBlitFramebuffer,
    &yagl_func_glGenRenderbuffers,
    &yagl_func_glBindRenderbuffer,
    &yagl_func_glRenderbufferStorage,
    &yagl_func_glGetRenderbufferParameteriv,
    &yagl_func_glCreateProgram,
    &yagl_func_glCreateShader,
    &yagl_func_glShaderSource,
    &yagl_func_glAttachShader,
    &yagl_func_glDetachShader,
    &yagl_func_glCompileShader,
    &yagl_func_glBindAttribLocation,
    &yagl_func_glGetActiveAttrib,
    &yagl_func_glGetActiveUniform,
    &yagl_func_glGetAttribLocation,
    &yagl_func_glGetProgramiv,
    &yagl_func_glGetProgramInfoLog,
    &yagl_func_glGetShaderiv,
    &yagl_func_glGetShaderInfoLog,
    &yagl_func_glGetUniformfv,
    &yagl_func_glGetUniformiv,
    &yagl_func_glGetUniformLocation,
    &yagl_func_glGetVertexAttribfv,
    &yagl_func_glGetVertexAttribiv,
    &yagl_func_glLinkProgram,
    &yagl_func_glUniform1f,
    &yagl_func_glUniform1fv,
    &yagl_func_glUniform1i,
    &yagl_func_glUniform1iv,
    &yagl_func_glUniform2f,
    &yagl_func_glUniform2fv,
    &yagl_func_glUniform2i,
    &yagl_func_glUniform2iv,
    &yagl_func_glUniform3f,
    &yagl_func_glUniform3fv,
    &yagl_func_glUniform3i,
    &yagl_func_glUniform3iv,
    &yagl_func_glUniform4f,
    &yagl_func_glUniform4fv,
    &yagl_func_glUniform4i,
    &yagl_func_glUniform4iv,
    &yagl_func_glUniformMatrix2fv,
    &yagl_func_glUniformMatrix3fv,
    &yagl_func_glUniformMatrix4fv,
    &yagl_func_glUseProgram,
    &yagl_func_glValidateProgram,
    &yagl_func_glVertexAttrib1f,
    &yagl_func_glVertexAttrib1fv,
    &yagl_func_glVertexAttrib2f,
    &yagl_func_glVertexAttrib2fv,
    &yagl_func_glVertexAttrib3f,
    &yagl_func_glVertexAttrib3fv,
    &yagl_func_glVertexAttrib4f,
    &yagl_func_glVertexAttrib4fv,
    &yagl_func_glGetIntegerv,
    &yagl_func_glGetFloatv,
    &yagl_func_glGetString,
    &yagl_func_glIsEnabled,
    &yagl_func_glDeleteObjects,
    &yagl_func_glBlendEquation,
    &yagl_func_glBlendEquationSeparate,
    &yagl_func_glBlendFunc,
    &yagl_func_glBlendFuncSeparate,
    &yagl_func_glBlendColor,
    &yagl_func_glClear,
    &yagl_func_glClearColor,
    &yagl_func_glClearDepthf,
    &yagl_func_glClearStencil,
    &yagl_func_glColorMask,
    &yagl_func_glCullFace,
    &yagl_func_glDepthFunc,
    &yagl_func_glDepthMask,
    &yagl_func_glDepthRangef,
    &yagl_func_glEnable,
    &yagl_func_glDisable,
    &yagl_func_glFlush,
    &yagl_func_glFrontFace,
    &yagl_func_glGenerateMipmap,
    &yagl_func_glHint,
    &yagl_func_glLineWidth,
    &yagl_func_glPixelStorei,
    &yagl_func_glPolygonOffset,
    &yagl_func_glScissor,
    &yagl_func_glStencilFunc,
    &yagl_func_glStencilMask,
    &yagl_func_glStencilOp,
    &yagl_func_glSampleCoverage,
    &yagl_func_glViewport,
    &yagl_func_glStencilFuncSeparate,
    &yagl_func_glStencilMaskSeparate,
    &yagl_func_glStencilOpSeparate,
    &yagl_func_glPointSize,
    &yagl_func_glAlphaFunc,
    &yagl_func_glMatrixMode,
    &yagl_func_glLoadIdentity,
    &yagl_func_glPopMatrix,
    &yagl_func_glPushMatrix,
    &yagl_func_glRotatef,
    &yagl_func_glTranslatef,
    &yagl_func_glScalef,
    &yagl_func_glOrthof,
    &yagl_func_glColor4f,
    &yagl_func_glColor4ub,
    &yagl_func_glNormal3f,
    &yagl_func_glPointParameterf,
    &yagl_func_glPointParameterfv,
    &yagl_func_glFogf,
    &yagl_func_glFogfv,
    &yagl_func_glFrustumf,
    &yagl_func_glLightf,
    &yagl_func_glLightfv,
    &yagl_func_glGetLightfv,
    &yagl_func_glLightModelf,
    &yagl_func_glLightModelfv,
    &yagl_func_glMaterialf,
    &yagl_func_glMaterialfv,
    &yagl_func_glGetMaterialfv,
    &yagl_func_glShadeModel,
    &yagl_func_glLogicOp,
    &yagl_func_glMultMatrixf,
    &yagl_func_glLoadMatrixf,
    &yagl_func_glClipPlanef,
    &yagl_func_glGetClipPlanef,
    &yagl_func_glUpdateOffscreenImageYAGL,
    &yagl_func_glGenUniformLocationYAGL,
    &yagl_func_glDeleteUniformLocationsYAGL,
};
