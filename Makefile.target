# -*- Mode: makefile -*-

include ../config-host.mak
include config-target.mak
include config-devices.mak
include $(SRC_PATH)/rules.mak

$(call set-vpath, $(SRC_PATH))
ifdef CONFIG_LINUX
QEMU_CFLAGS += -I../linux-headers
endif
QEMU_CFLAGS += -I.. -I$(SRC_PATH)/target-$(TARGET_BASE_ARCH) -DNEED_CPU_H

QEMU_CFLAGS+=-I$(SRC_PATH)/include

ifdef CONFIG_USER_ONLY
# user emulator name
QEMU_PROG=qemu-$(TARGET_ARCH2)
else
# system emulator name
ifneq (,$(findstring -mwindows,$(libs_softmmu)))
# Terminate program name with a 'w' because the linker builds a windows executable.
QEMU_PROGW=qemu-system-$(TARGET_ARCH2)w$(EXESUF)
endif # windows executable
QEMU_PROG=qemu-system-$(TARGET_ARCH2)$(EXESUF)
endif

PROGS=$(QEMU_PROG)
ifdef QEMU_PROGW
PROGS+=$(QEMU_PROGW)
endif
STPFILES=

config-target.h: config-target.h-timestamp
config-target.h-timestamp: config-target.mak

ifdef CONFIG_TRACE_SYSTEMTAP
stap: $(QEMU_PROG).stp

ifdef CONFIG_USER_ONLY
TARGET_TYPE=user
else
TARGET_TYPE=system
endif

$(QEMU_PROG).stp: $(SRC_PATH)/trace-events
	$(call quiet-command,$(TRACETOOL) \
		--format=stap \
		--backend=$(TRACE_BACKEND) \
		--binary=$(bindir)/$(QEMU_PROG) \
		--target-arch=$(TARGET_ARCH) \
		--target-type=$(TARGET_TYPE) \
		< $< > $@,"  GEN   $(TARGET_DIR)$(QEMU_PROG).stp")
else
stap:
endif

all: $(PROGS) stap check-gl

# Dummy command so that make thinks it has done something
	@true

CONFIG_NO_PCI = $(if $(subst n,,$(CONFIG_PCI)),n,y)
CONFIG_NO_KVM = $(if $(subst n,,$(CONFIG_KVM)),n,y)
CONFIG_NO_XEN = $(if $(subst n,,$(CONFIG_XEN)),n,y)
CONFIG_NO_GET_MEMORY_MAPPING = $(if $(subst n,,$(CONFIG_HAVE_GET_MEMORY_MAPPING)),n,y)
CONFIG_NO_CORE_DUMP = $(if $(subst n,,$(CONFIG_HAVE_CORE_DUMP)),n,y)

#########################################################
# cpu emulator library
obj-y = exec.o translate-all.o cpu-exec.o
obj-y += tcg/tcg.o tcg/optimize.o
obj-$(CONFIG_TCG_INTERPRETER) += tci.o
obj-$(CONFIG_TCG_INTERPRETER) += disas/tci.o
obj-y += fpu/softfloat.o
obj-y += target-$(TARGET_BASE_ARCH)/
obj-y += disas.o
obj-$(CONFIG_GDBSTUB_XML) += gdbstub-xml.o
obj-$(CONFIG_NO_KVM) += kvm-stub.o

#########################################################
# Linux user emulator target

ifdef CONFIG_LINUX_USER

QEMU_CFLAGS+=-I$(SRC_PATH)/linux-user/$(TARGET_ABI_DIR) -I$(SRC_PATH)/linux-user

obj-y += linux-user/
obj-y += gdbstub.o thunk.o user-exec.o

endif #CONFIG_LINUX_USER

#########################################################
# BSD user emulator target

ifdef CONFIG_BSD_USER

QEMU_CFLAGS+=-I$(SRC_PATH)/bsd-user -I$(SRC_PATH)/bsd-user/$(TARGET_ARCH)

obj-y += bsd-user/
obj-y += gdbstub.o user-exec.o

endif #CONFIG_BSD_USER

#########################################################
# System emulator target
ifdef CONFIG_SOFTMMU
obj-y += arch_init.o cpus.o monitor.o gdbstub.o balloon.o ioport.o
obj-y += qtest.o
obj-y += hw/
obj-$(CONFIG_FDT) += device_tree.o
obj-$(CONFIG_KVM) += kvm-all.o
obj-y += memory.o savevm.o cputlb.o
obj-$(CONFIG_HAVE_GET_MEMORY_MAPPING) += memory_mapping.o
obj-$(CONFIG_HAVE_CORE_DUMP) += dump.o
obj-$(CONFIG_NO_GET_MEMORY_MAPPING) += memory_mapping-stub.o
obj-$(CONFIG_NO_CORE_DUMP) += dump-stub.o
LIBS+=$(libs_softmmu)

# xen support
obj-$(CONFIG_XEN) += xen-all.o xen-mapcache.o
obj-$(CONFIG_NO_XEN) += xen-stub.o

# HAX support
ifdef CONFIG_WIN32
obj-$(CONFIG_HAX) += target-i386/hax-all.o target-i386/hax-windows.o
obj-$(CONFIG_NO_HAX) += hax-stub.o
endif
ifdef CONFIG_DARWIN
obj-$(CONFIG_HAX) += target-i386/hax-all.o target-i386/hax-darwin.o
obj-$(CONFIG_NO_HAX) += hax-stub.o
endif

# Hardware support
ifeq ($(TARGET_ARCH), sparc64)
obj-y += hw/sparc64/
else
obj-y += hw/$(TARGET_BASE_ARCH)/
endif

main.o: QEMU_CFLAGS+=$(GPROF_CFLAGS)

GENERATED_HEADERS += hmp-commands.h qmp-commands-old.h

endif # CONFIG_SOFTMMU

# Workaround for http://gcc.gnu.org/PR55489, see configure.
%/translate.o: QEMU_CFLAGS += $(TRANSLATE_OPT_CFLAGS)

nested-vars += obj-y

# Makefile for TIZEN-maru
ifdef CONFIG_MARU
include $(SRC_PATH)/tizen/src/Makefile.tizen
endif
##

ifdef CONFIG_BUILD_YAGL

# YaGL
QEMU_CFLAGS += -I$(SRC_PATH)/hw/yagl_inc

$(call set-vpath, $(SRC_PATH)/hw/yagl_apis/egl: \
                  $(SRC_PATH)/hw/yagl_apis/gles: \
                  $(SRC_PATH)/hw/yagl_apis/gles1: \
                  $(SRC_PATH)/hw/yagl_apis/gles2: \
                  $(SRC_PATH)/hw/yagl_backends/egl_offscreen: \
                  $(SRC_PATH)/hw/yagl_backends/egl_onscreen: \
                  $(SRC_PATH)/hw/yagl_drivers/egl_glx: \
                  $(SRC_PATH)/hw/yagl_drivers/egl_wgl: \
                  $(SRC_PATH)/hw/yagl_drivers/gles_ogl: \
                  $(SRC_PATH)/hw/yagl_drivers/gles_onscreen: \
                  $(SRC_PATH)/hw/yagl_drivers/gles1_ogl: \
                  $(SRC_PATH)/hw/yagl_drivers/gles2_ogl: \
                  $(SRC_PATH)/hw/yagl_drivers/gles1_onscreen: \
                  $(SRC_PATH)/hw/yagl_drivers/gles2_onscreen)

obj-y += yagl_device.o
obj-y += yagl_log.o
obj-y += yagl_process.o
obj-y += yagl_thread.o
obj-y += yagl_server.o
obj-y += yagl_ref.o
obj-y += yagl_mem.o
obj-y += yagl_mem_egl.o
obj-y += yagl_mem_gl.o
obj-y += yagl_mem_transfer.o
obj-y += yagl_event.o
obj-y += yagl_handle_gen.o
obj-y += yagl_dyn_lib.o
obj-y += yagl_api.o
obj-y += yagl_vector.o
obj-y += yagl_avl.o
obj-y += yagl_range_list.o
obj-y += yagl_egl_backend.o
obj-y += yagl_eglb_display.o
obj-y += yagl_eglb_context.o
obj-y += yagl_eglb_surface.o
obj-y += yagl_eglb_image.o
obj-y += yagl_egl_driver.o
obj-y += yagl_gles_driver.o
obj-y += yagl_gles1_driver.o
obj-y += yagl_gles2_driver.o
obj-y += yagl_egl_interface.o
obj-y += yagl_client_interface.o
obj-y += yagl_client_context.o
obj-y += yagl_client_image.o
obj-y += yagl_client_tex_image.o
obj-y += yagl_resource.o
obj-y += yagl_resource_list.o
obj-y += yagl_object.o
obj-y += yagl_namespace.o
obj-y += yagl_sharegroup.o
obj-y += yagl_stats.o
obj-y += yagl_compiled_transfer.o
obj-y += yagl_egl_native_config.o
obj-y += yagl_egl_surface_attribs.o
# EGL api
obj-y += yagl_egl_api.o
obj-y += yagl_egl_api_ps.o
obj-y += yagl_egl_api_ts.o
obj-y += yagl_egl_calls.o
obj-y += yagl_egl_display.o
obj-y += yagl_egl_config.o
obj-y += yagl_egl_surface.o
obj-y += yagl_egl_context.o
obj-y += yagl_egl_image.o
obj-y += yagl_egl_validate.o
obj-y += yagl_host_egl_calls.o
# GLES common api
obj-y += yagl_gles_context.o
obj-y += yagl_gles_array.o
obj-y += yagl_gles_buffer.o
obj-y += yagl_gles_texture.o
obj-y += yagl_gles_framebuffer.o
obj-y += yagl_gles_renderbuffer.o
obj-y += yagl_gles_image.o
obj-y += yagl_gles_tex_image.o
obj-y += yagl_gles_texture_unit.o
obj-y += yagl_gles_validate.o
obj-y += yagl_host_gles_calls.o
# GLESv1_CM api
obj-y += yagl_gles1_api.o
obj-y += yagl_gles1_api_ps.o
obj-y += yagl_gles1_api_ts.o
obj-y += yagl_gles1_calls.o
obj-y += yagl_gles1_context.o
obj-y += yagl_host_gles1_calls.o
# GLESv2 api
obj-y += yagl_gles2_api.o
obj-y += yagl_gles2_api_ps.o
obj-y += yagl_gles2_api_ts.o
obj-y += yagl_gles2_calls.o
obj-y += yagl_gles2_context.o
obj-y += yagl_gles2_shader.o
obj-y += yagl_gles2_program.o
obj-y += yagl_gles2_validate.o
obj-y += yagl_host_gles2_calls.o
# EGL offscreen backend
obj-y += yagl_egl_offscreen.o
obj-y += yagl_egl_offscreen_ts.o
obj-y += yagl_egl_offscreen_display.o
obj-y += yagl_egl_offscreen_context.o
obj-y += yagl_egl_offscreen_surface.o
obj-y += yagl_egl_offscreen_image.o
# EGL onscreen backend
obj-y += yagl_egl_onscreen.o
obj-y += yagl_egl_onscreen_ts.o
obj-y += yagl_egl_onscreen_display.o
obj-y += yagl_egl_onscreen_context.o
obj-y += yagl_egl_onscreen_surface.o
obj-y += yagl_egl_onscreen_image.o
# EGL GLX driver
ifdef CONFIG_LINUX
obj-y += yagl_egl_glx.o
endif
# EGL WGL driver
ifdef CONFIG_WIN32
obj-y += yagl_egl_wgl.o
endif
# GLES OpenGL common driver
obj-y += yagl_gles_ogl.o
# GLESv1_CM OpenGL driver
obj-y += yagl_gles1_ogl.o
# GLESv2 OpenGL driver
obj-y += yagl_gles2_ogl.o
# GLES onscreen common driver
obj-y += yagl_gles_onscreen.o
# GLESv1_CM onscreen driver
obj-y += yagl_gles1_onscreen.o
# GLESv2 onscreen driver
obj-y += yagl_gles2_onscreen.o

endif

ifdef CONFIG_BUILD_VIGS

# VIGS
QEMU_CFLAGS += -I$(SRC_PATH)/hw/vigs_inc

obj-y += vigs_log.o
obj-y += vigs_device.o
obj-y += vigs_comm.o
obj-y += vigs_server.o
obj-y += vigs_backend.o
obj-y += vigs_surface.o
obj-y += vigs_utils.o
obj-y += vigs_vector.o
obj-y += vigs_ref.o
obj-y += vigs_gl_backend.o
obj-y += vigs_sw_backend.o
# GL GLX backend
ifdef CONFIG_LINUX
obj-y += vigs_gl_backend_glx.o
endif
# GL WGL backend
ifdef CONFIG_WIN32
obj-y += vigs_gl_backend_wgl.o
endif

endif

# This resolves all nested paths, so it must come last
include $(SRC_PATH)/Makefile.objs

all-obj-y = $(obj-y)
all-obj-y += $(addprefix ../, $(common-obj-y))

ifndef CONFIG_HAIKU
LIBS+=-lm
endif

ifdef QEMU_PROGW
# The linker builds a windows executable. Make also a console executable.
$(QEMU_PROGW): $(all-obj-y) ../libqemuutil.a ../libqemustub.a
	$(call LINK,$^)
$(QEMU_PROG): $(QEMU_PROGW)
	$(call quiet-command,$(OBJCOPY) --subsystem console $(QEMU_PROGW) $(QEMU_PROG),"  GEN   $(TARGET_DIR)$(QEMU_PROG)")
else
$(QEMU_PROG): $(all-obj-y) ../libqemuutil.a ../libqemustub.a
	$(call LINK,$^)
endif

CHECK_GL_OBJS = check_gl.o gloffscreen_test.o gloffscreen_common.o 
CHECK_GL_LDFLAGS =
CHECK_GL_TARGET =
ifdef CONFIG_LINUX
CHECK_GL_OBJS += gloffscreen_xcomposite.o
#CHECK_GL_LDFLAGS += -lGL -lXcomposite -lXext -lglib-2.0
# Fix linking error on Ubuntu 13.04
CHECK_GL_LDFLAGS += -lGL -lXcomposite -lX11 -lXext -lglib-2.0
CHECK_GL_TARGET = check-gl
endif
ifdef CONFIG_WIN32
CHECK_GL_OBJS += gloffscreen_wgl.o
CHECK_GL_LDFLAGS += -fstack-protector `pkg-config --libs glib-2.0` -lopengl32 -lglu32 -lgdi32
CHECK_GL_TARGET = check-gl.exe
endif
ifdef CONFIG_DARWIN
CHECK_GL_OBJS += gloffscreen_agl.o
CHECK_GL_LDFLAGS += -mmacosx-version-min=10.4 `pkg-config --cflags --libs glib-2.0` -framework GLUT -framework OpenGL -framework AGL
CHECK_GL_TARGET = check-gl
endif

check-gl: check_gl.o
	gcc -o $(CHECK_GL_TARGET) $(CHECK_GL_OBJS) $(CHECK_GL_LDFLAGS)
check_gl.o: check_gl.c
	gcc -c ../tizen/src/check_gl.c

gdbstub-xml.c: $(TARGET_XML_FILES) $(SRC_PATH)/scripts/feature_to_c.sh
	$(call quiet-command,rm -f $@ && $(SHELL) $(SRC_PATH)/scripts/feature_to_c.sh $@ $(TARGET_XML_FILES),"  GEN   $(TARGET_DIR)$@")

hmp-commands.h: $(SRC_PATH)/hmp-commands.hx
	$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,"  GEN   $(TARGET_DIR)$@")

qmp-commands-old.h: $(SRC_PATH)/qmp-commands.hx
	$(call quiet-command,sh $(SRC_PATH)/scripts/hxtool -h < $< > $@,"  GEN   $(TARGET_DIR)$@")

clean:
	rm -f *.a *~ $(PROGS)
	rm -f $(shell find . -name '*.[od]')
	rm -f hmp-commands.h qmp-commands-old.h gdbstub-xml.c
ifdef CONFIG_TRACE_SYSTEMTAP
	rm -f *.stp
endif

install: all
ifneq ($(PROGS),)
	$(INSTALL) -m 755 $(PROGS) "$(DESTDIR)$(bindir)"
ifneq ($(STRIP),)
	$(STRIP) $(patsubst %,"$(DESTDIR)$(bindir)/%",$(PROGS))
endif
endif
ifdef CONFIG_TRACE_SYSTEMTAP
	$(INSTALL_DIR) "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset"
	$(INSTALL_DATA) $(QEMU_PROG).stp "$(DESTDIR)$(qemu_datadir)/../systemtap/tapset"
endif

GENERATED_HEADERS += config-target.h
Makefile: $(GENERATED_HEADERS)
